{
  "version": 3,
  "sources": ["../bundle-Fh0bng/checked-fetch.js", "../../../functions/_worker.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-Fh0bng/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-Fh0bng/middleware-loader.entry.ts"],
  "sourceRoot": "/home/sloth/Character_Sheet_Project/.wrangler/tmp/dev-Y17oM3",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "/**\n * Authoritative Combat System - Cloudflare Durable Object\n *\n * This Durable Object is the ONLY authority for combat state.\n * All clients are untrusted - validation happens server-side.\n *\n * Combat phases: setup -> initiative -> active-turn <-> reaction-interrupt -> resolution -> completed\n */\n\ninterface Env {\n  CAMPAIGN_DO: DurableObjectNamespace;\n  SUPABASE_URL?: string;\n  SUPABASE_SERVICE_ROLE_KEY?: string;\n}\n\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n// CORS HELPER\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n/**\n * Generate CORS headers for cross-origin requests\n * Allows requests from production, preview deployments, and localhost\n */\nfunction getCorsHeaders(request: Request): HeadersInit {\n  const origin = request.headers.get(\"Origin\");\n\n  const allowedOrigins = [\n    \"https://character-sheet-project.pages.dev\",\n    \"http://localhost:5173\",\n  ];\n\n  const isAllowed = origin && (\n    allowedOrigins.some(allowed => origin === allowed || origin.startsWith(allowed)) ||\n    /^https:\\/\\/[a-z0-9-]+\\.character-sheet-project\\.pages\\.dev$/.test(origin) ||\n    /^http:\\/\\/localhost(:\\d+)?$/.test(origin)\n  );\n\n  if (isAllowed) {\n    return {\n      \"Access-Control-Allow-Origin\": origin,\n      \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n      \"Access-Control-Allow-Headers\": \"Content-Type, Authorization, Upgrade, Connection\",\n      \"Access-Control-Max-Age\": \"86400\",\n      \"Access-Control-Allow-Credentials\": \"true\",\n    };\n  }\n\n  return {};\n}\n\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n// AUTHORITATIVE COMBAT TYPES (inline for Cloudflare Worker compatibility)\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ntype WoundType = \"blunt\" | \"burn\" | \"freeze\" | \"laceration\" | \"mental\" | \"necrosis\" | \"spiritual\";\ntype WoundCounts = Partial<Record<WoundType, number>>;\ntype StatusKey = string; // Allowing dynamic status keys\n\ntype CombatPhase =\n  | \"setup\"\n  | \"initiative-rolling\"\n  | \"initiative\"\n  | \"active-turn\"\n  | \"reaction-interrupt\"\n  | \"resolution\"\n  | \"completed\";\n\ntype EntityController = \"gm\" | `player:${string}`;\ntype EntityFaction = \"ally\" | \"enemy\";\ntype InitiativeMode = \"individual\" | \"group\";\ntype ActionType = \"attack\" | \"spell\" | \"ability\" | \"movement\" | \"item\" | \"other\";\ntype ReactionType = \"parry\" | \"dodge\" | \"counterspell\" | \"opportunity\" | \"other\";\n\ntype CombatLogType =\n  | \"combat_started\"\n  | \"combat_ended\"\n  | \"round_started\"\n  | \"turn_started\"\n  | \"turn_ended\"\n  | \"action_declared\"\n  | \"action_resolved\"\n  | \"action_cancelled\"\n  | \"reaction_declared\"\n  | \"reaction_resolved\"\n  | \"wounds_applied\"\n  | \"status_applied\"\n  | \"status_removed\"\n  | \"status_tick\"\n  | \"resources_updated\"\n  | \"gm_override\";\n\ntype GmOverrideType =\n  | \"modify_initiative\"\n  | \"adjust_ap\"\n  | \"adjust_energy\"\n  | \"force_reaction\"\n  | \"cancel_reaction\"\n  | \"skip_entity\"\n  | \"end_turn\"\n  | \"add_status\"\n  | \"remove_status\"\n  | \"modify_wounds\"\n  | \"set_phase\"\n  | \"end_combat\";\n\ninterface CombatStatusEffect {\n  key: StatusKey;\n  stacks: number;\n  duration: number | null;\n  tickDamage?: { woundType: WoundType; amount: number };\n}\n\ninterface CombatEntity {\n  id: string;\n  name: string;\n  controller: EntityController;\n  faction: EntityFaction;\n  skills: Record<string, number>;\n  initiativeSkill: string;\n  energy: { current: number; max: number };\n  ap: { current: number; max: number };\n  tier: number;\n  reaction: { available: boolean };\n  statusEffects: CombatStatusEffect[];\n  wounds: WoundCounts;\n  alive: boolean;\n  bestiaryEntryId?: string;\n  // Monster numbering\n  displayName?: string;\n  baseNameForNumbering?: string;\n  // Auto-roll settings\n  autoRollDefense?: boolean;\n  defaultDefenseSkill?: string;\n}\n\ninterface InitiativeEntry {\n  entityId: string;\n  roll: number;\n  skillValue: number;\n  currentEnergy: number;\n  groupId?: string;\n}\n\ninterface DiceRoll {\n  diceCount: number;\n  diceSize: number;\n  rawValues: number[];\n  keepHighest: boolean;\n  modifier: number;\n}\n\ninterface RollData {\n  skill: string;\n  modifier: number;\n  diceCount: number;\n  keepHighest: boolean;\n  rawDice: number[];\n  selectedDie: number;\n  total: number;\n  audit: string;\n}\n\ntype CriticalTier = \"normal\" | \"wicked\" | \"vicious\" | \"brutal\";\n\ninterface ContestOutcome {\n  winnerId: string | null;\n  loserId: string | null;\n  winnerTotal: number;\n  loserTotal: number;\n  criticalTier: CriticalTier;\n  isTie: boolean;\n}\n\ninterface SkillContestRequest {\n  contestId: string;\n  initiatorId: string;\n  initiatorSkill: string;\n  initiatorRoll: RollData;\n  targetId: string;\n  suggestedDefenseSkill?: string;\n  autoRollDefense: boolean;\n  status: \"pending\" | \"awaiting_defense\" | \"resolved\";\n  createdAt: string;\n  resolvedAt?: string;\n  outcome?: ContestOutcome;\n  defenderSkill?: string;\n  defenderRoll?: RollData;\n}\n\ninterface SkillCheckRequest {\n  checkId: string;\n  requesterId: string;\n  targetPlayerId: string;\n  targetEntityId: string;\n  skill: string;\n  targetNumber?: number;\n  status: \"pending\" | \"rolled\" | \"acknowledged\";\n  rollData?: RollData;\n  createdAt: string;\n  resolvedAt?: string;\n}\n\ninterface PendingAction {\n  actionId: string;\n  type: ActionType;\n  sourceEntityId: string;\n  targetEntityId?: string;\n  rollData?: RollData;\n  apCost: number;\n  energyCost: number;\n  interruptible: boolean;\n  timestamp: string;\n  metadata?: Record<string, unknown>;\n}\n\ninterface ReactionEffect {\n  type: \"cancel_action\" | \"modify_action\" | \"apply_wounds\" | \"apply_status\" | \"reduce_damage\";\n  targetEntityId: string;\n  data?: {\n    wounds?: WoundCounts;\n    statusKey?: StatusKey;\n    statusStacks?: number;\n    statusDuration?: number;\n    damageReduction?: number;\n  };\n}\n\ninterface PendingReaction {\n  reactionId: string;\n  entityId: string;\n  type: ReactionType;\n  targetActionId: string;\n  skill?: string;\n  rollData?: RollData;\n  apCost: number;\n  energyCost: number;\n  timestamp: string;\n  effects?: ReactionEffect[];\n}\n\ninterface CombatLogEntry {\n  id: string;\n  timestamp: string;\n  type: CombatLogType;\n  sourceEntityId?: string;\n  targetEntityId?: string;\n  data?: Record<string, unknown>;\n}\n\ninterface PlayerCombatState {\n  playerId: string;\n  connectionId: string;\n  controlledEntities: string[];\n  connected: boolean;\n  lastSeen: string;\n}\n\ninterface AuthoritativeCombatState {\n  combatId: string;\n  campaignId: string;\n  phase: CombatPhase;\n  round: number;\n  turnIndex: number;\n  initiativeOrder: string[];\n  activeEntityId: string | null;\n  initiativeMode: InitiativeMode;\n  initiativeRolls: Record<string, InitiativeEntry>;\n  entities: Record<string, CombatEntity>;\n  grid: { allies: string[]; enemies: string[] };\n  players: Record<string, PlayerCombatState>;\n  pendingAction: PendingAction | null;\n  pendingReactions: PendingReaction[];\n  pendingSkillContests: Record<string, SkillContestRequest>;\n  pendingSkillChecks: Record<string, SkillCheckRequest>;\n  monsterNameCounters: Record<string, number>;\n  log: CombatLogEntry[];\n  version: number;\n  startedAt: string;\n  lastUpdatedAt: string;\n}\n\ninterface GmOverride {\n  type: GmOverrideType;\n  gmId: string;\n  targetEntityId?: string;\n  data?: Record<string, unknown>;\n  reason?: string;\n  timestamp: string;\n}\n\n// Legacy types for backward compatibility\ntype LegacyCombatEventType =\n  | \"combat_started\"\n  | \"turn_started\"\n  | \"turn_ended\"\n  | \"combat_updated\"\n  | \"ambush_applied\"\n  | \"ambush_resolved\"\n  | \"status_tick\"\n  | \"reaction_spent\"\n  | \"action_spent\";\n\ntype LegacyCombatEventLogEntry = {\n  id: string;\n  type: LegacyCombatEventType;\n  timestamp: string;\n  payload?: unknown;\n};\n\ntype LegacyCombatState = {\n  round: number;\n  turnIndex: number;\n  initiativeOrder: string[];\n  activeCombatantId: string | null;\n  ambushRoundFlags: Record<string, boolean>;\n  actionPointsById: Record<string, number>;\n  actionPointsMaxById: Record<string, number>;\n  energyById: Record<string, number>;\n  statusEffectsById: Record<string, string[]>;\n  woundsById: Record<string, number>;\n  reactionsUsedById: Record<string, number>;\n  eventLog: LegacyCombatEventLogEntry[];\n};\n\n// Server event types for WebSocket broadcast\ntype ServerEventType =\n  | \"STATE_SYNC\"\n  | \"COMBAT_STARTED\"\n  | \"COMBAT_ENDED\"\n  | \"ROUND_STARTED\"\n  | \"TURN_STARTED\"\n  | \"TURN_ENDED\"\n  | \"ACTION_DECLARED\"\n  | \"ACTION_REJECTED\"\n  | \"ACTION_RESOLVED\"\n  | \"REACTION_DECLARED\"\n  | \"REACTION_REJECTED\"\n  | \"REACTIONS_RESOLVED\"\n  | \"ENTITY_UPDATED\"\n  | \"WOUNDS_APPLIED\"\n  | \"STATUS_APPLIED\"\n  | \"STATUS_REMOVED\"\n  | \"STATUS_TICK\"\n  | \"GM_OVERRIDE\"\n  | \"INITIATIVE_MODIFIED\";\n\ntype CampaignEvent = {\n  type: \"roll\" | \"contest\" | \"presence\" | \"welcome\" | LegacyCombatEventType | ServerEventType;\n  sequence?: number;\n  campaignId: string;\n  timestamp: string;\n  payload?: unknown;\n};\n\ntype PresenceEntry = {\n  connectionId: string;\n  userId: string;\n  connectedAt: string;\n};\n\ntype StoredPresence = {\n  userId: string;\n  connectedAt: string;\n};\n\ntype RollRequestPayload = {\n  playerId: string;\n  playerName?: string;\n  modifier?: number;\n  label?: string;\n  skill?: string;\n  requestId?: string;\n};\n\ntype CombatantStartPayload = {\n  id: string;\n  initiative?: number;\n  initiativeRoll?: number;\n  initiativeBonus?: number;\n  actionPoints?: number;\n  energy?: number;\n  statusEffects?: string[];\n  wounds?: number;\n  ambushed?: boolean;\n  groupId?: string;\n};\n\ntype CombatStartPayload = {\n  combatants: CombatantStartPayload[];\n  groupInitiative: boolean;\n  ambushedIds?: string[];\n};\n\ntype CombatAdvancePayload = {\n  statusEffectsById?: Record<string, string[]>;\n};\n\ntype CombatAmbushPayload = {\n  combatantId?: string;\n};\n\ntype CombatSpendPayload = {\n  combatantId: string;\n  actionPointCost: number;\n  energyCost: number;\n  actionType?: string;\n  targetId?: string;\n  rollResults?: unknown;\n  metadata?: unknown;\n};\n\ntype CombatReactionPayload = {\n  combatantId: string;\n  actionPointCost: number;\n  reactionType?: string;\n  metadata?: unknown;\n};\n\ntype ContestSelectionPayload = {\n  requestId: string;\n  gmId: string;\n  gmName?: string;\n  npcName?: string;\n  npcModifier?: number;\n  contestId?: string;\n};\n\ntype RollRequestRecord = {\n  id: string;\n  campaignId: string;\n  playerId: string;\n  playerName?: string;\n  modifier: number;\n  roll: number;\n  total: number;\n  label?: string;\n  skill?: string;\n  createdAt: string;\n  status: \"pending\" | \"contested\";\n  contestId?: string;\n};\n\ntype ContestRecord = {\n  id: string;\n  campaignId: string;\n  requestId: string;\n  gmId: string;\n  gmName?: string;\n  npcName?: string;\n  npcModifier: number;\n  npcRoll: number;\n  npcTotal: number;\n  playerRoll: number;\n  playerModifier: number;\n  playerTotal: number;\n  outcome: \"player\" | \"npc\" | \"tie\";\n  createdAt: string;\n};\n\ninterface LobbyPlayerState {\n  userId: string;\n  characterId?: string;\n  isReady: boolean;\n  joinedAt: string;\n}\n\ninterface LobbyState {\n  campaignId: string;\n  players: Record<string, LobbyPlayerState>;\n  readyCount: number;\n  totalCount: number;\n}\n\nexport class CampaignDurableObject {\n  private state: DurableObjectState;\n  private env: Env;\n  private sessions = new Map<string, WebSocket>();\n  private presence = new Map<string, StoredPresence>();\n  private lobbyState: LobbyState | null = null;\n  private sequence = 0;\n  private ready: Promise<void>;\n\n  constructor(state: DurableObjectState, env: Env) {\n    this.state = state;\n    this.env = env;\n    this.ready = this.state.blockConcurrencyWhile(async () => {\n      const storedSequence = await this.state.storage.get<number>(\"sequence\");\n      if (typeof storedSequence === \"number\") {\n        this.sequence = storedSequence;\n      }\n\n      // Load lobby state from storage\n      const storedLobbyState = await this.state.storage.get<LobbyState>(\"lobbyState\");\n      if (storedLobbyState) {\n        this.lobbyState = storedLobbyState;\n      }\n    });\n  }\n\n  async fetch(request: Request): Promise<Response> {\n    await this.ready;\n\n    // Handle CORS preflight requests FIRST\n    if (request.method === \"OPTIONS\") {\n      return new Response(null, {\n        status: 204,\n        headers: getCorsHeaders(request),\n      });\n    }\n\n    const url = new URL(request.url);\n    const match = url.pathname.match(/^\\/api\\/campaigns\\/([^/]+)\\/(connect|roll|contest)$/);\n    const combatMatch = url.pathname.match(\n      /^\\/api\\/campaigns\\/([^/]+)\\/combat\\/([^/]+)$/,\n    );\n    if (!match && !combatMatch) {\n      return jsonResponse({ error: \"Not found\" }, 404);\n    }\n\n    const campaignId = decodeURIComponent((match ?? combatMatch)![1]);\n    const action = (match ?? combatMatch)![2];\n\n    // Handle WebSocket upgrades (before POST check)\n    if (action === \"connect\") {\n      return this.handleConnect(request, campaignId);\n    }\n\n    // Now check POST requirement for other endpoints\n    if (request.method !== \"POST\") {\n      return jsonResponse({ error: \"Method not allowed\" }, 405, { Allow: \"POST\" }, request);\n    }\n\n    const body = await readJsonBody(request);\n    if (body instanceof Response) {\n      return body;\n    }\n\n    if (action === \"roll\") {\n      return this.handleRollRequest(campaignId, body, request);\n    }\n\n    if (action === \"contest\") {\n      return this.handleContestRequest(campaignId, body, request);\n    }\n\n    if (combatMatch) {\n      return this.handleCombatAction(campaignId, action, body, request);\n    }\n\n    return jsonResponse({ error: \"Not found\" }, 404, {}, request);\n  }\n\n  private async handleConnect(request: Request, campaignId: string): Promise<Response> {\n    if (request.headers.get(\"Upgrade\") !== \"websocket\") {\n      return jsonResponse({ error: \"Expected WebSocket upgrade\" }, 426, {}, request);\n    }\n\n    const url = new URL(request.url);\n    const connectionId = crypto.randomUUID();\n    const userId = url.searchParams.get(\"user\") ?? connectionId;\n\n    const pair = new WebSocketPair();\n    const client = pair[0];\n    const server = pair[1];\n    server.accept();\n\n    this.sessions.set(connectionId, server);\n    this.presence.set(connectionId, {\n      userId,\n      connectedAt: new Date().toISOString(),\n    });\n\n    server.addEventListener(\"message\", (event) => {\n      void this.handleClientMessage(connectionId, campaignId, event.data);\n    });\n\n    server.addEventListener(\"close\", () => {\n      this.handleDisconnect(connectionId, campaignId);\n    });\n\n    server.addEventListener(\"error\", () => {\n      this.handleDisconnect(connectionId, campaignId);\n    });\n\n    const welcomePayload: CampaignEvent = {\n      type: \"welcome\",\n      campaignId,\n      timestamp: new Date().toISOString(),\n      payload: {\n        connectionId,\n        presence: this.currentPresence(),\n        sequence: this.sequence,\n      },\n    };\n    server.send(JSON.stringify(welcomePayload));\n\n    // Send current lobby state to the new connection\n    if (this.lobbyState) {\n      const lobbyStateSync = {\n        type: \"LOBBY_STATE_SYNC\",\n        campaignId,\n        timestamp: new Date().toISOString(),\n        payload: {\n          lobbyState: this.lobbyState,\n        },\n      };\n      server.send(JSON.stringify(lobbyStateSync));\n    }\n\n    this.broadcast({\n      type: \"presence\",\n      campaignId,\n      timestamp: new Date().toISOString(),\n      payload: {\n        action: \"join\",\n        ...this.serializePresence(connectionId),\n        total: this.presence.size,\n      },\n    });\n\n    return new Response(null, {\n      status: 101,\n      webSocket: client,\n      headers: getCorsHeaders(request),\n    });\n  }\n\n  private async handleClientMessage(connectionId: string, campaignId: string, data: unknown) {\n    if (typeof data !== \"string\") {\n      return;\n    }\n\n    let payload: { type?: string; userId?: string; characterId?: string; isReady?: boolean } | undefined;\n    try {\n      payload = JSON.parse(data);\n    } catch {\n      return;\n    }\n\n    // Handle presence updates\n    if (payload?.type === \"presence\" && payload.userId) {\n      const current = this.presence.get(connectionId);\n      if (!current || current.userId === payload.userId) {\n        return;\n      }\n\n      this.presence.set(connectionId, { ...current, userId: payload.userId });\n      this.broadcast({\n        type: \"presence\",\n        campaignId,\n        timestamp: new Date().toISOString(),\n        payload: {\n          action: \"update\",\n          ...this.serializePresence(connectionId),\n          total: this.presence.size,\n        },\n      });\n    }\n\n    // Handle lobby events\n    if (payload?.type === \"LOBBY_JOIN\" && payload.userId) {\n      this.handleLobbyJoin(campaignId, payload.userId, payload.characterId);\n    }\n\n    if (payload?.type === \"LOBBY_LEAVE\" && payload.userId) {\n      this.handleLobbyLeave(campaignId, payload.userId);\n    }\n\n    if (payload?.type === \"LOBBY_TOGGLE_READY\" && payload.userId) {\n      this.handleLobbyToggleReady(campaignId, payload.userId, payload.isReady ?? false, payload.characterId);\n    }\n\n    if (payload?.type === \"REQUEST_STATE\") {\n      const combatState = await this.loadAuthCombatState(campaignId);\n      const socket = this.sessions.get(connectionId);\n      if (!combatState || !socket) return;\n\n      socket.send(JSON.stringify({\n        type: \"STATE_SYNC\",\n        campaignId,\n        timestamp: new Date().toISOString(),\n        payload: { state: combatState },\n      }));\n    }\n  }\n\n  private handleDisconnect(connectionId: string, campaignId: string) {\n    if (!this.sessions.has(connectionId)) {\n      return;\n    }\n\n    this.sessions.delete(connectionId);\n    const presenceEntry = this.serializePresence(connectionId);\n    this.presence.delete(connectionId);\n\n    this.broadcast({\n      type: \"presence\",\n      campaignId,\n      timestamp: new Date().toISOString(),\n      payload: {\n        action: \"leave\",\n        ...presenceEntry,\n        total: this.presence.size,\n      },\n    });\n  }\n\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  // LOBBY MANAGEMENT\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n  private initializeLobby(campaignId: string) {\n    if (!this.lobbyState) {\n      this.lobbyState = {\n        campaignId,\n        players: {},\n        readyCount: 0,\n        totalCount: 0,\n      };\n    }\n  }\n\n  private async saveLobbyState() {\n    if (this.lobbyState) {\n      await this.state.storage.put(\"lobbyState\", this.lobbyState);\n    }\n  }\n\n  private handleLobbyJoin(campaignId: string, userId: string, characterId?: string) {\n    this.initializeLobby(campaignId);\n\n    if (!this.lobbyState) return;\n\n    const joinedAt = new Date().toISOString();\n    const wasReady = this.lobbyState.players[userId]?.isReady ?? false;\n\n    this.lobbyState.players[userId] = {\n      userId,\n      characterId,\n      isReady: wasReady, // Preserve ready state if rejoining\n      joinedAt,\n    };\n\n    this.lobbyState.totalCount = Object.keys(this.lobbyState.players).length;\n    this.lobbyState.readyCount = Object.values(this.lobbyState.players).filter(p => p.isReady).length;\n\n    // Save to storage\n    this.saveLobbyState();\n\n    // Broadcast to all clients\n    this.broadcast({\n      type: \"LOBBY_PLAYER_JOINED\",\n      campaignId,\n      timestamp: joinedAt,\n      payload: {\n        userId,\n        characterId,\n        joinedAt,\n        lobbyState: this.lobbyState,\n      },\n    });\n  }\n\n  private handleLobbyLeave(campaignId: string, userId: string) {\n    if (!this.lobbyState || !this.lobbyState.players[userId]) return;\n\n    delete this.lobbyState.players[userId];\n\n    this.lobbyState.totalCount = Object.keys(this.lobbyState.players).length;\n    this.lobbyState.readyCount = Object.values(this.lobbyState.players).filter(p => p.isReady).length;\n\n    const leftAt = new Date().toISOString();\n\n    // Save to storage\n    this.saveLobbyState();\n\n    // Broadcast to all clients\n    this.broadcast({\n      type: \"LOBBY_PLAYER_LEFT\",\n      campaignId,\n      timestamp: leftAt,\n      payload: {\n        userId,\n        leftAt,\n        lobbyState: this.lobbyState,\n      },\n    });\n  }\n\n  private handleLobbyToggleReady(campaignId: string, userId: string, isReady: boolean, characterId?: string) {\n    this.initializeLobby(campaignId);\n\n    if (!this.lobbyState) return;\n\n    // Ensure player exists in lobby\n    if (!this.lobbyState.players[userId]) {\n      this.lobbyState.players[userId] = {\n        userId,\n        characterId,\n        isReady: false,\n        joinedAt: new Date().toISOString(),\n      };\n    }\n\n    // Update ready state\n    this.lobbyState.players[userId].isReady = isReady;\n    if (characterId) {\n      this.lobbyState.players[userId].characterId = characterId;\n    }\n\n    this.lobbyState.readyCount = Object.values(this.lobbyState.players).filter(p => p.isReady).length;\n\n    // Save to storage\n    this.saveLobbyState();\n\n    // Broadcast to all clients\n    this.broadcast({\n      type: \"LOBBY_PLAYER_READY\",\n      campaignId,\n      timestamp: new Date().toISOString(),\n      payload: {\n        userId,\n        isReady,\n        characterId,\n        lobbyState: this.lobbyState,\n      },\n    });\n  }\n\n  private async nextSequence() {\n    const next = this.sequence + 1;\n    this.sequence = next;\n    await this.state.storage.put(\"sequence\", next);\n    return next;\n  }\n\n  private combatStateKey(campaignId: string) {\n    return `combat_state:${campaignId}`;\n  }\n\n  private async loadCombatState(campaignId: string): Promise<CombatState | null> {\n    return this.state.blockConcurrencyWhile(async () => {\n      return this.state.storage.get<CombatState>(this.combatStateKey(campaignId));\n    });\n  }\n\n  private async saveCombatState(campaignId: string, combatState: CombatState): Promise<number> {\n    return this.state.blockConcurrencyWhile(async () => {\n      const next = this.sequence + 1;\n      this.sequence = next;\n      await this.state.storage.put({\n        [this.combatStateKey(campaignId)]: combatState,\n        sequence: next,\n      });\n      return next;\n    });\n  }\n\n  private async broadcastCombatEvent(\n    campaignId: string,\n    type: CombatEventType,\n    payload?: unknown,\n  ) {\n    const sequence = await this.saveCombatStateSequence();\n    this.broadcast({\n      type,\n      campaignId,\n      sequence,\n      timestamp: new Date().toISOString(),\n      payload,\n    });\n  }\n\n  private async saveCombatStateSequence(): Promise<number> {\n    return this.state.blockConcurrencyWhile(async () => {\n      const next = this.sequence + 1;\n      this.sequence = next;\n      await this.state.storage.put(\"sequence\", next);\n      return next;\n    });\n  }\n\n  private async handleRollRequest(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    const parsed = parseRollRequest(body);\n    if (parsed instanceof Response) {\n      return parsed;\n    }\n\n    const requestId = parsed.requestId ?? crypto.randomUUID();\n    const roll = rollD100();\n    const modifier = parsed.modifier ?? 0;\n    const total = roll + modifier;\n    const createdAt = new Date().toISOString();\n\n    const record: RollRequestRecord = {\n      id: requestId,\n      campaignId,\n      playerId: parsed.playerId,\n      playerName: parsed.playerName,\n      modifier,\n      roll,\n      total,\n      label: parsed.label,\n      skill: parsed.skill,\n      createdAt,\n      status: \"pending\",\n    };\n\n    const persistenceError = await this.persistSupabase(\n      \"roll_requests\",\n      mapRollRequestForSupabase(record),\n      { upsert: true },\n    );\n    if (persistenceError) {\n      return persistenceError;\n    }\n\n    await this.state.storage.put(this.rollRequestKey(requestId), record);\n\n    const sequence = await this.nextSequence();\n    const event: CampaignEvent = {\n      type: \"roll\",\n      campaignId,\n      sequence,\n      timestamp: createdAt,\n      payload: { request: record },\n    };\n\n    this.broadcast(event);\n\n    return jsonResponse({ ok: true, sequence, request: record }, 200, {}, request);\n  }\n\n  private async handleContestRequest(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    const parsed = parseContestSelection(body);\n    if (parsed instanceof Response) {\n      return parsed;\n    }\n\n    const requestKey = this.rollRequestKey(parsed.requestId);\n    const rollRequest = await this.state.storage.get<RollRequestRecord>(requestKey);\n    if (!rollRequest) {\n      return jsonResponse({ error: \"Roll request not found.\" }, 404, {}, request);\n    }\n\n    const contestId = parsed.contestId ?? crypto.randomUUID();\n    const npcRoll = rollD100();\n    const npcModifier = parsed.npcModifier ?? 0;\n    const npcTotal = npcRoll + npcModifier;\n    const createdAt = new Date().toISOString();\n    const outcome =\n      rollRequest.total === npcTotal ? \"tie\" : rollRequest.total > npcTotal ? \"player\" : \"npc\";\n\n    const contest: ContestRecord = {\n      id: contestId,\n      campaignId,\n      requestId: rollRequest.id,\n      gmId: parsed.gmId,\n      gmName: parsed.gmName,\n      npcName: parsed.npcName,\n      npcModifier,\n      npcRoll,\n      npcTotal,\n      playerRoll: rollRequest.roll,\n      playerModifier: rollRequest.modifier,\n      playerTotal: rollRequest.total,\n      outcome,\n      createdAt,\n    };\n\n    const updatedRequest: RollRequestRecord = {\n      ...rollRequest,\n      status: \"contested\",\n      contestId,\n    };\n\n    const persistenceError = await this.persistSupabase(\n      \"roll_contests\",\n      mapContestForSupabase(contest),\n      { upsert: true },\n    );\n    if (persistenceError) {\n      return persistenceError;\n    }\n\n    const requestUpdateError = await this.persistSupabase(\n      \"roll_requests\",\n      mapRollRequestForSupabase(updatedRequest),\n      { upsert: true },\n    );\n    if (requestUpdateError) {\n      return requestUpdateError;\n    }\n\n    await this.state.storage.put(requestKey, updatedRequest);\n    await this.state.storage.put(this.rollContestKey(contestId), contest);\n\n    const sequence = await this.nextSequence();\n    const event: CampaignEvent = {\n      type: \"contest\",\n      campaignId,\n      sequence,\n      timestamp: createdAt,\n      payload: { request: updatedRequest, contest },\n    };\n\n    this.broadcast(event);\n\n    return jsonResponse({ ok: true, sequence, contest }, 200, {}, request);\n  }\n\n  private async handleCombatAction(\n    campaignId: string,\n    action: string,\n    body: unknown,\n    request: Request,\n  ): Promise<Response> {\n    switch (action) {\n      // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n      // AUTHORITATIVE COMBAT SYSTEM (new)\n      // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n      case \"auth-state\":\n        return this.handleAuthoritativeState(campaignId, request);\n      case \"auth-start\":\n        return this.handleAuthoritativeStart(campaignId, body, request);\n      case \"auth-submit-initiative-roll\":\n        return this.handleSubmitInitiativeRoll(campaignId, body, request);\n      case \"auth-declare-action\":\n        return this.handleDeclareAction(campaignId, body, request);\n      case \"auth-declare-reaction\":\n        return this.handleDeclareReaction(campaignId, body, request);\n      case \"auth-resolve-reactions\":\n        return this.handleResolveReactions(campaignId, body, request);\n      case \"auth-end-turn\":\n        return this.handleAuthoritativeEndTurn(campaignId, body, request);\n      case \"auth-gm-override\":\n        return this.handleGmOverride(campaignId, body, request);\n      case \"auth-end-combat\":\n        return this.handleEndCombat(campaignId, body, request);\n      case \"auth-initiate-skill-contest\":\n        return this.handleInitiateSkillContest(campaignId, body, request);\n      case \"auth-respond-skill-contest\":\n        return this.handleRespondSkillContest(campaignId, body, request);\n      case \"auth-request-skill-check\":\n        return this.handleRequestSkillCheck(campaignId, body, request);\n      case \"auth-submit-skill-check\":\n        return this.handleSubmitSkillCheck(campaignId, body, request);\n      case \"auth-remove-entity\":\n        return this.handleRemoveEntity(campaignId, body, request);\n\n      // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n      // LEGACY COMBAT SYSTEM (preserved for backward compatibility)\n      // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n      case \"state\":\n        return this.handleCombatState(campaignId, request);\n      case \"start\":\n        return this.handleCombatStart(campaignId, body, request);\n      case \"advance\":\n      case \"advance-turn\":\n        return this.handleCombatAdvance(campaignId, body, request);\n      case \"resolve-ambush\":\n        return this.handleCombatAmbush(campaignId, body, request);\n      case \"spend\":\n        return this.handleCombatSpend(campaignId, body, request);\n      case \"reaction\":\n        return this.handleCombatReaction(campaignId, body, request);\n      default:\n        return jsonResponse({ error: \"Not found\" }, 404, {}, request);\n    }\n  }\n\n  private async handleCombatState(campaignId: string, request: Request): Promise<Response> {\n    const combatState = await this.loadCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    return jsonResponse({ ok: true, sequence: this.sequence, state: combatState }, 200, {}, request);\n  }\n\n  private async handleCombatAmbush(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    const parsed = parseCombatAmbush(body);\n    if (parsed instanceof Response) {\n      return parsed;\n    }\n\n    const combatState = await this.loadCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const targetId = parsed.combatantId ?? combatState.activeCombatantId;\n    if (!targetId) {\n      return jsonResponse({ error: \"Combatant not available for ambush resolution.\" }, 400, {}, request);\n    }\n\n    const hadAmbushPenalty = combatState.ambushRoundFlags[targetId] ?? false;\n    if (hadAmbushPenalty) {\n      combatState.ambushRoundFlags[targetId] = false;\n    }\n\n    const ambushEntry = createCombatEventLogEntry(\"ambush_resolved\", {\n      combatantId: targetId,\n      hadAmbushPenalty,\n    });\n    combatState.eventLog.push(ambushEntry);\n\n    const sequence = await this.saveCombatState(campaignId, combatState);\n    this.broadcast({\n      type: \"ambush_resolved\",\n      campaignId,\n      sequence,\n      timestamp: ambushEntry.timestamp,\n      payload: { state: combatState, combatantId: targetId, hadAmbushPenalty },\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState }, 200, {}, request);\n  }\n\n  private async handleCombatStart(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    const parsed = parseCombatStart(body);\n    if (parsed instanceof Response) {\n      return parsed;\n    }\n\n    let combatants = parsed.combatants;\n    if (combatants.length === 0) {\n      const loaded = await this.loadCombatantsFromSupabase(campaignId);\n      if (loaded instanceof Response) {\n        return loaded;\n      }\n      combatants = loaded;\n    }\n\n    if (combatants.length === 0) {\n      return jsonResponse({ error: \"No combatants available to start combat.\" }, 400, {}, request);\n    }\n\n    const ambushedSet = new Set(parsed.ambushedIds ?? []);\n    const initiativeScores = new Map<string, number>();\n    const groupScores = new Map<string, number>();\n\n    combatants.forEach((combatant) => {\n      const score =\n        (combatant.initiative ?? 0) +\n        (combatant.initiativeRoll ?? 0) +\n        (combatant.initiativeBonus ?? 0);\n      initiativeScores.set(combatant.id, score);\n      if (parsed.groupInitiative) {\n        const groupKey = combatant.groupId ?? combatant.id;\n        const current = groupScores.get(groupKey);\n        if (current == null || score > current) {\n          groupScores.set(groupKey, score);\n        }\n      }\n    });\n\n    const initiativeOrder = [...combatants]\n      .sort((left, right) => {\n        const leftScore = parsed.groupInitiative\n          ? groupScores.get(left.groupId ?? left.id) ?? 0\n          : initiativeScores.get(left.id) ?? 0;\n        const rightScore = parsed.groupInitiative\n          ? groupScores.get(right.groupId ?? right.id) ?? 0\n          : initiativeScores.get(right.id) ?? 0;\n        if (leftScore !== rightScore) {\n          return rightScore - leftScore;\n        }\n        const leftTie = initiativeScores.get(left.id) ?? 0;\n        const rightTie = initiativeScores.get(right.id) ?? 0;\n        if (leftTie !== rightTie) {\n          return rightTie - leftTie;\n        }\n        return left.id.localeCompare(right.id);\n      })\n      .map((combatant) => combatant.id);\n\n    const now = new Date().toISOString();\n    const combatState: CombatState = {\n      round: 1,\n      turnIndex: 0,\n      initiativeOrder,\n      activeCombatantId: initiativeOrder[0] ?? null,\n      ambushRoundFlags: {},\n      actionPointsById: {},\n      actionPointsMaxById: {},\n      energyById: {},\n      statusEffectsById: {},\n      woundsById: {},\n      reactionsUsedById: {},\n      eventLog: [],\n    };\n\n    for (const combatant of combatants) {\n      const id = combatant.id;\n      const actionPoints = combatant.actionPoints ?? 0;\n      combatState.actionPointsById[id] = actionPoints;\n      combatState.actionPointsMaxById[id] = actionPoints;\n      combatState.energyById[id] = combatant.energy ?? 0;\n      combatState.statusEffectsById[id] = combatant.statusEffects ?? [];\n      combatState.woundsById[id] = combatant.wounds ?? 0;\n      combatState.reactionsUsedById[id] = 0;\n      if (combatant.ambushed || ambushedSet.has(id)) {\n        combatState.ambushRoundFlags[id] = true;\n      }\n    }\n\n    const startedEntry = createCombatEventLogEntry(\"combat_started\", {\n      initiativeOrder,\n      groupInitiative: parsed.groupInitiative,\n    });\n    combatState.eventLog.push(startedEntry);\n\n    if (combatState.activeCombatantId) {\n      combatState.eventLog.push(\n        createCombatEventLogEntry(\"turn_started\", {\n          combatantId: combatState.activeCombatantId,\n          round: combatState.round,\n          turnIndex: combatState.turnIndex,\n        }),\n      );\n    }\n\n    const sequence = await this.saveCombatState(campaignId, combatState);\n    this.broadcast({\n      type: \"combat_started\",\n      campaignId,\n      sequence,\n      timestamp: now,\n      payload: { state: combatState },\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState }, 200, {}, request);\n  }\n\n  private async handleCombatAdvance(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    const parsed = parseCombatAdvance(body);\n    if (parsed instanceof Response) {\n      return parsed;\n    }\n\n    const combatState = await this.loadCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const now = new Date().toISOString();\n    const previousCombatantId = combatState.activeCombatantId;\n\n    if (parsed.statusEffectsById) {\n      for (const [combatantId, statusEffects] of Object.entries(parsed.statusEffectsById)) {\n        combatState.statusEffectsById[combatantId] = statusEffects;\n      }\n    }\n\n    if (previousCombatantId) {\n      combatState.eventLog.push(\n        createCombatEventLogEntry(\"turn_ended\", {\n          combatantId: previousCombatantId,\n          round: combatState.round,\n          turnIndex: combatState.turnIndex,\n        }),\n      );\n    }\n\n    combatState.eventLog.push(\n      createCombatEventLogEntry(\"status_tick\", {\n        combatantId: previousCombatantId,\n        updatedStatusEffects: parsed.statusEffectsById ?? null,\n      }),\n    );\n\n    const hadAmbushPenalty = Boolean(\n      previousCombatantId != null &&\n        combatState.round === 1 &&\n        combatState.ambushRoundFlags[previousCombatantId],\n    );\n    if (previousCombatantId && hadAmbushPenalty) {\n      combatState.ambushRoundFlags[previousCombatantId] = false;\n      combatState.eventLog.push(\n        createCombatEventLogEntry(\"ambush_applied\", {\n          skippedCombatants: [previousCombatantId],\n        }),\n      );\n    }\n\n    const order = combatState.initiativeOrder;\n    let nextIndex = combatState.turnIndex + 1;\n    let nextRound = combatState.round;\n    if (order.length === 0) {\n      combatState.turnIndex = 0;\n      combatState.activeCombatantId = null;\n    } else {\n      if (nextIndex >= order.length) {\n        nextIndex = 0;\n        nextRound += 1;\n      }\n      combatState.turnIndex = nextIndex;\n      combatState.round = nextRound;\n      combatState.activeCombatantId = order[nextIndex] ?? null;\n    }\n\n    if (combatState.activeCombatantId) {\n      const activeId = combatState.activeCombatantId;\n      const maxActionPoints = combatState.actionPointsMaxById[activeId];\n      if (typeof maxActionPoints === \"number\") {\n        combatState.actionPointsById[activeId] = maxActionPoints;\n      }\n      combatState.eventLog.push(\n        createCombatEventLogEntry(\"turn_started\", {\n          combatantId: activeId,\n          round: combatState.round,\n          turnIndex: combatState.turnIndex,\n        }),\n      );\n    }\n\n    const sequence = await this.saveCombatState(campaignId, combatState);\n    this.broadcast({\n      type: \"turn_started\",\n      campaignId,\n      sequence,\n      timestamp: now,\n      payload: {\n        state: combatState,\n        previousCombatantId,\n        ambushCleared: hadAmbushPenalty,\n      },\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState }, 200, {}, request);\n  }\n\n  private async handleCombatSpend(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    const parsed = parseCombatSpend(body);\n    if (parsed instanceof Response) {\n      return parsed;\n    }\n\n    if (parsed.actionPointCost < 0) {\n      return jsonResponse({ error: \"Action point costs must be non-negative.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const currentAp = combatState.actionPointsById[parsed.combatantId] ?? 0;\n    const nextAp = currentAp - parsed.actionPointCost;\n    if (nextAp < 0) {\n      return jsonResponse({ error: \"Insufficient action points.\" }, 400, {}, request);\n    }\n\n    const currentEnergy = combatState.energyById[parsed.combatantId] ?? 0;\n    const nextEnergy = currentEnergy - parsed.energyCost;\n    if (nextEnergy < 0) {\n      return jsonResponse({ error: \"Insufficient energy.\" }, 400, {}, request);\n    }\n\n    combatState.actionPointsById[parsed.combatantId] = nextAp;\n    combatState.energyById[parsed.combatantId] = nextEnergy;\n\n    const actionEntry = createCombatEventLogEntry(\"action_spent\", {\n      combatantId: parsed.combatantId,\n      actionPointCost: parsed.actionPointCost,\n      energyCost: parsed.energyCost,\n      actionType: parsed.actionType,\n      targetId: parsed.targetId,\n      rollResults: parsed.rollResults ?? null,\n      metadata: parsed.metadata ?? null,\n    });\n    combatState.eventLog.push(actionEntry);\n\n    const sequence = await this.saveCombatState(campaignId, combatState);\n    this.broadcast({\n      type: \"action_spent\",\n      campaignId,\n      sequence,\n      timestamp: actionEntry.timestamp,\n      payload: { state: combatState, action: actionEntry.payload },\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState }, 200, {}, request);\n  }\n\n  private async handleCombatReaction(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    const parsed = parseCombatReaction(body);\n    if (parsed instanceof Response) {\n      return parsed;\n    }\n\n    if (parsed.actionPointCost < 0) {\n      return jsonResponse({ error: \"Costs must be non-negative.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const currentAp = combatState.actionPointsById[parsed.combatantId] ?? 0;\n    const nextAp = currentAp - parsed.actionPointCost;\n    if (nextAp < 0) {\n      return jsonResponse({ error: \"Insufficient action points.\" }, 400, {}, request);\n    }\n\n    combatState.actionPointsById[parsed.combatantId] = nextAp;\n    combatState.reactionsUsedById[parsed.combatantId] =\n      (combatState.reactionsUsedById[parsed.combatantId] ?? 0) + 1;\n\n    const reactionEntry = createCombatEventLogEntry(\"reaction_spent\", {\n      combatantId: parsed.combatantId,\n      actionPointCost: parsed.actionPointCost,\n      reactionType: parsed.reactionType,\n      metadata: parsed.metadata ?? null,\n    });\n    combatState.eventLog.push(reactionEntry);\n\n    const sequence = await this.saveCombatState(campaignId, combatState);\n    this.broadcast({\n      type: \"reaction_spent\",\n      campaignId,\n      sequence,\n      timestamp: reactionEntry.timestamp,\n      payload: { state: combatState, reaction: reactionEntry.payload },\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState }, 200, {}, request);\n  }\n\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  // AUTHORITATIVE COMBAT SYSTEM HANDLERS\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n  private authCombatStateKey(campaignId: string): string {\n    return `auth_combat_state:${campaignId}`;\n  }\n\n  private async loadAuthCombatState(campaignId: string): Promise<AuthoritativeCombatState | null> {\n    return this.state.blockConcurrencyWhile(async () => {\n      return this.state.storage.get<AuthoritativeCombatState>(this.authCombatStateKey(campaignId));\n    });\n  }\n\n  private async saveAuthCombatState(\n    campaignId: string,\n    combatState: AuthoritativeCombatState\n  ): Promise<number> {\n    return this.state.blockConcurrencyWhile(async () => {\n      const next = this.sequence + 1;\n      this.sequence = next;\n      combatState.version = next;\n      combatState.lastUpdatedAt = new Date().toISOString();\n      await this.state.storage.put({\n        [this.authCombatStateKey(campaignId)]: combatState,\n        sequence: next,\n      });\n      return next;\n    });\n  }\n\n  private broadcastAuthEvent(\n    type: ServerEventType,\n    campaignId: string,\n    sequence: number,\n    payload: unknown\n  ): void {\n    this.broadcast({\n      type,\n      campaignId,\n      sequence,\n      timestamp: new Date().toISOString(),\n      payload,\n    });\n  }\n\n  private createAuthLogEntry(\n    type: CombatLogType,\n    sourceEntityId?: string,\n    targetEntityId?: string,\n    data?: Record<string, unknown>\n  ): CombatLogEntry {\n    return {\n      id: crypto.randomUUID(),\n      timestamp: new Date().toISOString(),\n      type,\n      sourceEntityId,\n      targetEntityId,\n      data,\n    };\n  }\n\n  // Validation: Check if entity can take an action\n  private validateAction(\n    state: AuthoritativeCombatState,\n    entityId: string,\n    senderId: string,\n    apCost: number,\n    energyCost: number\n  ): { allowed: boolean; reason?: string } {\n    if (state.phase !== \"active-turn\") {\n      return { allowed: false, reason: \"Not in active-turn phase\" };\n    }\n\n    if (state.activeEntityId !== entityId) {\n      return { allowed: false, reason: \"Not your turn\" };\n    }\n\n    const entity = state.entities[entityId];\n    if (!entity) {\n      return { allowed: false, reason: \"Entity not found\" };\n    }\n\n    if (!entity.alive) {\n      return { allowed: false, reason: \"Entity is not alive\" };\n    }\n\n    // Check controller matches (GM can control any entity)\n    const isGm = senderId === \"gm\" || senderId.startsWith(\"gm:\");\n    if (!isGm && entity.controller !== senderId && entity.controller !== `player:${senderId}`) {\n      return { allowed: false, reason: \"You do not control this entity\" };\n    }\n\n    if (entity.ap.current < apCost) {\n      return { allowed: false, reason: `Insufficient AP (have ${entity.ap.current}, need ${apCost})` };\n    }\n\n    if (entity.energy.current < energyCost) {\n      return { allowed: false, reason: `Insufficient energy (have ${entity.energy.current}, need ${energyCost})` };\n    }\n\n    return { allowed: true };\n  }\n\n  // Validation: Check if entity can declare a reaction\n  private validateReaction(\n    state: AuthoritativeCombatState,\n    entityId: string,\n    senderId: string\n  ): { allowed: boolean; reason?: string } {\n    const entity = state.entities[entityId];\n\n    if (!entity) {\n      return { allowed: false, reason: \"Entity not found\" };\n    }\n\n    if (!entity.alive) {\n      return { allowed: false, reason: \"Entity is not alive\" };\n    }\n\n    if (!entity.reaction.available) {\n      return { allowed: false, reason: \"Reaction already used this round\" };\n    }\n\n    if (state.activeEntityId === entityId) {\n      return { allowed: false, reason: \"Cannot react during your own turn\" };\n    }\n\n    if (state.phase !== \"active-turn\" && state.phase !== \"reaction-interrupt\") {\n      return { allowed: false, reason: \"Cannot declare reactions in current phase\" };\n    }\n\n    if (!state.pendingAction) {\n      return { allowed: false, reason: \"No pending action to react to\" };\n    }\n\n    if (!state.pendingAction.interruptible) {\n      return { allowed: false, reason: \"Pending action cannot be interrupted\" };\n    }\n\n    // Check controller matches (GM can control any entity)\n    const isGm = senderId === \"gm\" || senderId.startsWith(\"gm:\");\n    if (!isGm && entity.controller !== senderId && entity.controller !== `player:${senderId}`) {\n      return { allowed: false, reason: \"You do not control this entity\" };\n    }\n\n    return { allowed: true };\n  }\n\n  private validateTurnEnd(\n    state: AuthoritativeCombatState,\n    entityId: string,\n    senderId: string\n  ): { allowed: boolean; reason?: string } {\n    const entity = state.entities[entityId];\n\n    if (!entity) {\n      return { allowed: false, reason: \"Entity not found\" };\n    }\n\n    if (state.activeEntityId !== entityId) {\n      return { allowed: false, reason: \"Not the active entity's turn\" };\n    }\n\n    const isGm = senderId === \"gm\" || senderId.startsWith(\"gm:\");\n    if (!isGm && entity.controller !== senderId && entity.controller !== `player:${senderId}`) {\n      return { allowed: false, reason: \"You do not control this entity\" };\n    }\n\n    return { allowed: true };\n  }\n\n  private validateDiceRoll(roll: DiceRoll): true | string {\n    if (roll.diceCount < 1 || roll.diceCount > 20) {\n      return \"Dice count must be between 1 and 20\";\n    }\n\n    if (roll.diceSize < 2 || roll.diceSize > 100) {\n      return \"Dice size must be between 2 and 100\";\n    }\n\n    if (roll.rawValues.length !== roll.diceCount) {\n      return \"Raw values count does not match dice count\";\n    }\n\n    for (const value of roll.rawValues) {\n      if (value < 1 || value > roll.diceSize) {\n        return `Dice value ${value} is out of range [1, ${roll.diceSize}]`;\n      }\n      if (!Number.isInteger(value)) {\n        return \"Dice values must be integers\";\n      }\n    }\n\n    return true;\n  }\n\n  private calculateRollResult(roll: DiceRoll, skill: string, skillModifier: number): RollData {\n    const selectedDie = roll.keepHighest\n      ? Math.max(...roll.rawValues)\n      : Math.min(...roll.rawValues);\n\n    const total = selectedDie + roll.modifier + skillModifier;\n\n    const audit = `${roll.diceCount}d${roll.diceSize} [${roll.rawValues.join(\", \")}] ` +\n      `${roll.keepHighest ? \"highest\" : \"lowest\"}=${selectedDie} ` +\n      `+ ${roll.modifier} (modifier) + ${skillModifier} (${skill}) = ${total}`;\n\n    return {\n      skill,\n      modifier: skillModifier,\n      diceCount: roll.diceCount,\n      keepHighest: roll.keepHighest,\n      rawDice: roll.rawValues,\n      selectedDie,\n      total,\n      audit\n    };\n  }\n\n  private validateAndConvertRoll(\n    roll: DiceRoll,\n    skill: string,\n    skillModifier: number,\n    request: Request\n  ): RollData | Response {\n    const validation = this.validateDiceRoll(roll);\n    if (validation !== true) {\n      return jsonResponse({ error: validation }, 400, {}, request);\n    }\n\n    return this.calculateRollResult(roll, skill, skillModifier);\n  }\n\n  // Sort initiative with tiebreakers\n  private sortInitiative(entries: InitiativeEntry[]): string[] {\n    return [...entries]\n      .sort((a, b) => {\n        if (a.roll !== b.roll) return b.roll - a.roll;\n        if (a.skillValue !== b.skillValue) return b.skillValue - a.skillValue;\n        if (a.currentEnergy !== b.currentEnergy) return b.currentEnergy - a.currentEnergy;\n        return a.entityId.localeCompare(b.entityId);\n      })\n      .map(e => e.entityId);\n  }\n\n  // Sort initiative with group mode\n  private sortGroupInitiative(\n    entries: InitiativeEntry[],\n    entities: Record<string, CombatEntity>\n  ): string[] {\n    const groups: Record<EntityFaction, InitiativeEntry[]> = { ally: [], enemy: [] };\n\n    for (const entry of entries) {\n      const entity = entities[entry.entityId];\n      if (entity) {\n        groups[entity.faction].push(entry);\n      }\n    }\n\n    const groupBests: { faction: EntityFaction; bestEntry: InitiativeEntry }[] = [];\n\n    for (const [faction, factionEntries] of Object.entries(groups) as [EntityFaction, InitiativeEntry[]][]) {\n      if (factionEntries.length === 0) continue;\n      const sorted = this.sortInitiative(factionEntries);\n      const bestEntry = factionEntries.find(e => e.entityId === sorted[0])!;\n      groupBests.push({ faction, bestEntry });\n    }\n\n    groupBests.sort((a, b) => {\n      const aE = a.bestEntry;\n      const bE = b.bestEntry;\n      if (aE.roll !== bE.roll) return bE.roll - aE.roll;\n      if (aE.skillValue !== bE.skillValue) return bE.skillValue - aE.skillValue;\n      if (aE.currentEnergy !== bE.currentEnergy) return bE.currentEnergy - aE.currentEnergy;\n      return aE.entityId.localeCompare(bE.entityId);\n    });\n\n    const result: string[] = [];\n    for (const { faction } of groupBests) {\n      result.push(...this.sortInitiative(groups[faction]));\n    }\n    return result;\n  }\n\n  // Handler: Get current authoritative combat state\n  private async handleAuthoritativeState(campaignId: string, request: Request): Promise<Response> {\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    return jsonResponse({ ok: true, sequence: this.sequence, state: combatState }, 200, {}, request);\n  }\n\n  // Handler: Start authoritative combat\n  private async handleAuthoritativeStart(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const initiativeMode = body.initiativeMode === \"group\" ? \"group\" : \"individual\";\n    const manualInitiative = body.manualInitiative === true;\n    const entities = body.entities as Record<string, CombatEntity> | undefined;\n\n    if (!entities || Object.keys(entities).length === 0) {\n      return jsonResponse({ error: \"No entities provided.\" }, 400, {}, request);\n    }\n\n    let initiativeRolls: Record<string, InitiativeEntry> = {};\n    let initiativeOrder: string[] = [];\n\n    // If manual initiative, wait for player rolls\n    if (manualInitiative) {\n      // Don't roll initiative automatically\n      initiativeOrder = [];\n    } else {\n      // Roll initiative automatically for each entity\n      for (const [entityId, entity] of Object.entries(entities)) {\n        const roll = rollD100();\n        const skillValue = entity.skills[entity.initiativeSkill] ?? 0;\n        initiativeRolls[entityId] = {\n          entityId,\n          roll,\n          skillValue,\n          currentEnergy: entity.energy.current,\n        };\n      }\n\n      // Sort initiative\n      initiativeOrder = initiativeMode === \"group\"\n        ? this.sortGroupInitiative(Object.values(initiativeRolls), entities)\n        : this.sortInitiative(Object.values(initiativeRolls));\n    }\n\n    const now = new Date().toISOString();\n    const combatId = crypto.randomUUID();\n\n    // Build grid\n    const allies = Object.entries(entities)\n      .filter(([_, e]) => e.faction === \"ally\")\n      .map(([id]) => id);\n    const enemies = Object.entries(entities)\n      .filter(([_, e]) => e.faction === \"enemy\")\n      .map(([id]) => id);\n\n    // Auto-number duplicate monsters\n    const numberedEntities = this.assignMonsterDisplayNames(entities);\n\n    const combatState: AuthoritativeCombatState = {\n      combatId,\n      campaignId,\n      phase: manualInitiative ? \"initiative-rolling\" : \"active-turn\",\n      round: 1,\n      turnIndex: 0,\n      initiativeOrder,\n      activeEntityId: manualInitiative ? null : (initiativeOrder[0] ?? null),\n      initiativeMode,\n      initiativeRolls,\n      entities: numberedEntities,\n      grid: { allies, enemies },\n      players: {},\n      pendingAction: null,\n      pendingReactions: [],\n      pendingSkillContests: {},\n      pendingSkillChecks: {},\n      monsterNameCounters: {},\n      log: [],\n      version: 0,\n      startedAt: now,\n      lastUpdatedAt: now,\n    };\n\n    // Reset AP and reaction for first entity (only if not manual initiative)\n    if (!manualInitiative && combatState.activeEntityId) {\n      const activeEntity = combatState.entities[combatState.activeEntityId];\n      if (activeEntity) {\n        activeEntity.ap.current = activeEntity.ap.max;\n        activeEntity.reaction.available = true;\n      }\n    }\n\n    // Add combat started log\n    combatState.log.push(this.createAuthLogEntry(\"combat_started\", undefined, undefined, {\n      initiativeOrder,\n      initiativeMode,\n      entityCount: Object.keys(entities).length,\n      manualInitiative,\n    }));\n\n    // Add turn started log (only if not manual initiative)\n    if (!manualInitiative && combatState.activeEntityId) {\n      combatState.log.push(this.createAuthLogEntry(\"turn_started\", combatState.activeEntityId, undefined, {\n        round: 1,\n        turnIndex: 0,\n      }));\n    }\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n    this.broadcastAuthEvent(\"COMBAT_STARTED\", campaignId, sequence, { state: combatState });\n\n    return jsonResponse({ ok: true, sequence, state: combatState }, 200, {}, request);\n  }\n\n  // Handler: Submit initiative roll\n  private async handleSubmitInitiativeRoll(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const entityId = body.entityId as string | undefined;\n    const roll = body.roll as any;\n\n    if (!entityId || !roll) {\n      return jsonResponse({ error: \"Missing entityId or roll.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat not found.\" }, 404, {}, request);\n    }\n\n    if (combatState.phase !== \"initiative-rolling\") {\n      return jsonResponse({ error: \"Combat is not in initiative-rolling phase.\" }, 400, {}, request);\n    }\n\n    const entity = combatState.entities[entityId];\n    if (!entity) {\n      return jsonResponse({ error: \"Entity not found.\" }, 404, {}, request);\n    }\n\n    // Validate dice roll\n    const validation = this.validateDiceRoll(roll);\n    if (validation !== true) {\n      return jsonResponse({ error: validation }, 400, {}, request);\n    }\n\n    // Calculate roll result\n    const skillModifier = entity.skills[entity.initiativeSkill] ?? 0;\n    const rollResult = this.calculateRollResult(roll, entity.initiativeSkill, skillModifier);\n\n    // Store initiative roll\n    combatState.initiativeRolls[entityId] = {\n      entityId,\n      roll: rollResult.selectedDie,\n      skillValue: skillModifier,\n      currentEnergy: entity.energy.current,\n    };\n\n    // Broadcast roll submitted event\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n    this.broadcastAuthEvent(\"INITIATIVE_ROLL_SUBMITTED\", campaignId, sequence, {\n      entityId,\n      playerId: \"\", // TODO: Get from request\n      roll: rollResult,\n    });\n\n    // Check if all entities have rolled\n    const allEntityIds = Object.keys(combatState.entities);\n    const rolledEntityIds = Object.keys(combatState.initiativeRolls);\n    const allRolled = allEntityIds.every(id => rolledEntityIds.includes(id));\n\n    if (allRolled) {\n      // Compute initiative order\n      const initiativeOrder = combatState.initiativeMode === \"group\"\n        ? this.sortGroupInitiative(Object.values(combatState.initiativeRolls), combatState.entities)\n        : this.sortInitiative(Object.values(combatState.initiativeRolls));\n\n      combatState.initiativeOrder = initiativeOrder;\n      combatState.phase = \"active-turn\";\n      combatState.activeEntityId = initiativeOrder[0] ?? null;\n      combatState.turnIndex = 0;\n\n      // Reset AP and reaction for first entity\n      if (combatState.activeEntityId) {\n        const activeEntity = combatState.entities[combatState.activeEntityId];\n        if (activeEntity) {\n          activeEntity.ap.current = activeEntity.ap.max;\n          activeEntity.reaction.available = true;\n        }\n      }\n\n      // Add turn started log\n      if (combatState.activeEntityId) {\n        combatState.log.push(this.createAuthLogEntry(\"turn_started\", combatState.activeEntityId, undefined, {\n          round: 1,\n          turnIndex: 0,\n        }));\n      }\n\n      const finalSequence = await this.saveAuthCombatState(campaignId, combatState);\n\n      // Broadcast all initiative rolled event\n      this.broadcastAuthEvent(\"ALL_INITIATIVE_ROLLED\", campaignId, finalSequence, {\n        initiativeOrder,\n        rollResults: Object.fromEntries(\n          Object.entries(combatState.initiativeRolls).map(([id, entry]) => [id, {\n            skill: combatState.entities[id]?.initiativeSkill || \"initiative\",\n            modifier: entry.skillValue,\n            diceCount: 1,\n            keepHighest: true,\n            rawDice: [entry.roll],\n            selectedDie: entry.roll,\n            total: entry.roll + entry.skillValue,\n            audit: `1d100 [${entry.roll}] + ${entry.skillValue} = ${entry.roll + entry.skillValue}`,\n          }])\n        ),\n      });\n\n      return jsonResponse({ ok: true, sequence: finalSequence, state: combatState }, 200, {}, request);\n    }\n\n    return jsonResponse({ ok: true, sequence, state: combatState }, 200, {}, request);\n  }\n\n  // Handler: Declare an action\n  private async handleDeclareAction(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const entityId = parseRequiredStringField(body.entityId, \"entityId\", request);\n    if (entityId instanceof Response) return entityId;\n\n    const senderId = parseRequiredStringField(body.senderId, \"senderId\", request);\n    if (senderId instanceof Response) return senderId;\n\n    const actionType = (body.type as ActionType) ?? \"other\";\n    const targetEntityId = parseStringField(body.targetEntityId, \"targetEntityId\", false, request);\n    if (targetEntityId instanceof Response) return targetEntityId;\n\n    const apCost = parseNumberField(body.apCost, \"apCost\", 0, request);\n    if (apCost instanceof Response) return apCost;\n\n    const energyCost = parseNumberField(body.energyCost, \"energyCost\", 0, request);\n    if (energyCost instanceof Response) return energyCost;\n\n    const interruptible = body.interruptible !== false;\n\n    // Validate the action\n    const validation = this.validateAction(combatState, entityId, senderId, apCost, energyCost);\n    if (!validation.allowed) {\n      const sequence = await this.saveAuthCombatState(campaignId, combatState);\n      this.broadcastAuthEvent(\"ACTION_REJECTED\", campaignId, sequence, {\n        entityId,\n        reason: validation.reason,\n      });\n      return jsonResponse({ ok: false, error: validation.reason }, 400, {}, request);\n    }\n\n    // Deduct resources\n    const entity = combatState.entities[entityId];\n    entity.ap.current -= apCost;\n    entity.energy.current -= energyCost;\n\n    // Create pending action\n    const pendingAction: PendingAction = {\n      actionId: crypto.randomUUID(),\n      type: actionType,\n      sourceEntityId: entityId,\n      targetEntityId: targetEntityId ?? undefined,\n      apCost,\n      energyCost,\n      interruptible,\n      timestamp: new Date().toISOString(),\n      metadata: body.metadata as Record<string, unknown> | undefined,\n    };\n\n    combatState.pendingAction = pendingAction;\n    combatState.log.push(this.createAuthLogEntry(\"action_declared\", entityId, targetEntityId ?? undefined, {\n      actionType,\n      apCost,\n      energyCost,\n      interruptible,\n    }));\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n    this.broadcastAuthEvent(\"ACTION_DECLARED\", campaignId, sequence, {\n      action: pendingAction,\n      phase: combatState.phase,\n      state: combatState,\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState, action: pendingAction }, 200, {}, request);\n  }\n\n  // Handler: Declare a reaction\n  private async handleDeclareReaction(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const entityId = parseRequiredStringField(body.entityId, \"entityId\", request);\n    if (entityId instanceof Response) return entityId;\n\n    const senderId = parseRequiredStringField(body.senderId, \"senderId\", request);\n    if (senderId instanceof Response) return senderId;\n\n    const reactionType = (body.type as ReactionType) ?? \"other\";\n\n    const apCost = parseNumberField(body.apCost, \"apCost\", 0, request);\n    if (apCost instanceof Response) return apCost;\n\n    const energyCost = parseNumberField(body.energyCost, \"energyCost\", 0, request);\n    if (energyCost instanceof Response) return energyCost;\n\n    // Validate the reaction\n    const validation = this.validateReaction(combatState, entityId, senderId);\n    if (!validation.allowed) {\n      const sequence = await this.saveAuthCombatState(campaignId, combatState);\n      this.broadcastAuthEvent(\"REACTION_REJECTED\", campaignId, sequence, {\n        entityId,\n        reason: validation.reason,\n      });\n      return jsonResponse({ ok: false, error: validation.reason }, 400, {}, request);\n    }\n\n    // Check AP cost\n    const entity = combatState.entities[entityId];\n    if (entity.ap.current < apCost) {\n      return jsonResponse({ ok: false, error: \"Insufficient AP for reaction\" }, 400, {}, request);\n    }\n\n    // Deduct resources and mark reaction as used\n    entity.ap.current -= apCost;\n    entity.energy.current = Math.max(0, entity.energy.current - energyCost);\n    entity.reaction.available = false;\n\n    // Create pending reaction\n    const pendingReaction: PendingReaction = {\n      reactionId: crypto.randomUUID(),\n      entityId,\n      type: reactionType,\n      targetActionId: combatState.pendingAction!.actionId,\n      skill: body.skill as string | undefined,\n      apCost,\n      energyCost,\n      timestamp: new Date().toISOString(),\n      effects: body.effects as ReactionEffect[] | undefined,\n    };\n\n    combatState.pendingReactions.push(pendingReaction);\n\n    // Transition to reaction-interrupt phase if not already there\n    if (combatState.phase === \"active-turn\") {\n      combatState.phase = \"reaction-interrupt\";\n    }\n\n    combatState.log.push(this.createAuthLogEntry(\"reaction_declared\", entityId, undefined, {\n      reactionType,\n      targetActionId: pendingReaction.targetActionId,\n      apCost,\n      energyCost,\n    }));\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n    this.broadcastAuthEvent(\"REACTION_DECLARED\", campaignId, sequence, {\n      reaction: pendingReaction,\n      pendingReactionsCount: combatState.pendingReactions.length,\n      state: combatState,\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState, reaction: pendingReaction }, 200, {}, request);\n  }\n\n  // Handler: Resolve pending reactions (GM triggers this)\n  private async handleResolveReactions(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const senderId = parseRequiredStringField(body.senderId, \"senderId\", request);\n    if (senderId instanceof Response) return senderId;\n\n    const isGm = senderId === \"gm\" || senderId.startsWith(\"gm:\");\n    if (!isGm) {\n      return jsonResponse({ error: \"Only GM can resolve reactions.\" }, 403, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    if (!combatState.pendingAction) {\n      return jsonResponse({ error: \"No pending action to resolve.\" }, 400, {}, request);\n    }\n\n    // Transition to resolution phase\n    combatState.phase = \"resolution\";\n\n    // Sort reactions by initiative order\n    const reactorOrder = combatState.initiativeOrder.filter(id =>\n      combatState.pendingReactions.some(r => r.entityId === id)\n    );\n\n    const sortedReactions = reactorOrder\n      .map(id => combatState.pendingReactions.find(r => r.entityId === id)!)\n      .filter(Boolean);\n\n    let actionCancelled = false;\n    let actionModified = false;\n    const resolvedReactions: Array<{ reaction: PendingReaction; success: boolean; effects: ReactionEffect[] }> = [];\n\n    // Resolve each reaction in initiative order\n    for (const reaction of sortedReactions) {\n      // For now, assume all reactions succeed (actual contest logic would go here)\n      const success = true;\n      const effects = reaction.effects ?? [];\n\n      // Apply reaction effects\n      for (const effect of effects) {\n        switch (effect.type) {\n          case \"cancel_action\":\n            actionCancelled = true;\n            break;\n          case \"modify_action\":\n            actionModified = true;\n            break;\n          case \"apply_wounds\":\n            if (effect.data?.wounds) {\n              const target = combatState.entities[effect.targetEntityId];\n              if (target) {\n                for (const [woundType, count] of Object.entries(effect.data.wounds)) {\n                  const current = target.wounds[woundType as WoundType] ?? 0;\n                  target.wounds[woundType as WoundType] = current + (count as number);\n                }\n                combatState.log.push(this.createAuthLogEntry(\"wounds_applied\", reaction.entityId, effect.targetEntityId, {\n                  wounds: effect.data.wounds,\n                  source: \"reaction\",\n                }));\n              }\n            }\n            break;\n          case \"apply_status\":\n            if (effect.data?.statusKey) {\n              const target = combatState.entities[effect.targetEntityId];\n              if (target) {\n                target.statusEffects.push({\n                  key: effect.data.statusKey,\n                  stacks: effect.data.statusStacks ?? 1,\n                  duration: effect.data.statusDuration ?? null,\n                });\n                combatState.log.push(this.createAuthLogEntry(\"status_applied\", reaction.entityId, effect.targetEntityId, {\n                  statusKey: effect.data.statusKey,\n                  stacks: effect.data.statusStacks ?? 1,\n                  duration: effect.data.statusDuration ?? null,\n                }));\n              }\n            }\n            break;\n        }\n      }\n\n      resolvedReactions.push({ reaction, success, effects });\n\n      combatState.log.push(this.createAuthLogEntry(\"reaction_resolved\", reaction.entityId, undefined, {\n        reactionId: reaction.reactionId,\n        success,\n        effectCount: effects.length,\n      }));\n    }\n\n    // Clear pending reactions\n    combatState.pendingReactions = [];\n\n    // Resolve or cancel the original action\n    if (actionCancelled) {\n      combatState.log.push(this.createAuthLogEntry(\"action_cancelled\", combatState.pendingAction.sourceEntityId, undefined, {\n        actionId: combatState.pendingAction.actionId,\n        reason: \"cancelled_by_reaction\",\n      }));\n    } else {\n      combatState.log.push(this.createAuthLogEntry(\"action_resolved\", combatState.pendingAction.sourceEntityId, combatState.pendingAction.targetEntityId, {\n        actionId: combatState.pendingAction.actionId,\n        modified: actionModified,\n      }));\n    }\n\n    // Clear pending action\n    const resolvedAction = combatState.pendingAction;\n    combatState.pendingAction = null;\n\n    // Transition back to active-turn\n    combatState.phase = \"active-turn\";\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n    this.broadcastAuthEvent(\"REACTIONS_RESOLVED\", campaignId, sequence, {\n      reactions: resolvedReactions,\n      action: resolvedAction,\n      actionCancelled,\n      actionModified,\n      state: combatState,\n    });\n\n    return jsonResponse({\n      ok: true,\n      sequence,\n      state: combatState,\n      reactions: resolvedReactions,\n      actionCancelled,\n      actionModified,\n    }, 200, {}, request);\n  }\n\n  // Handler: End turn (voluntary or forced)\n  private async handleAuthoritativeEndTurn(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    if (combatState.phase === \"completed\") {\n      return jsonResponse({ error: \"Combat has already ended.\" }, 400, {}, request);\n    }\n\n    const entityId = parseRequiredStringField(body.entityId, \"entityId\", request);\n    if (entityId instanceof Response) return entityId;\n\n    const senderId = parseRequiredStringField(body.senderId, \"senderId\", request);\n    if (senderId instanceof Response) return senderId;\n\n    const validation = this.validateTurnEnd(combatState, entityId, senderId);\n    if (!validation.allowed) {\n      return jsonResponse({ error: validation.reason }, 403, {}, request);\n    }\n\n    // Resolve any pending action/reactions first\n    if (combatState.pendingAction) {\n      combatState.pendingAction = null;\n      combatState.pendingReactions = [];\n    }\n\n    const previousEntityId = combatState.activeEntityId;\n    const previousEntity = previousEntityId ? combatState.entities[previousEntityId] : null;\n\n    // Log turn end\n    if (previousEntityId) {\n      const voluntary = body.voluntary !== false;\n      combatState.log.push(this.createAuthLogEntry(\"turn_ended\", previousEntityId, undefined, {\n        round: combatState.round,\n        turnIndex: combatState.turnIndex,\n        voluntary,\n      }));\n    }\n\n    // Advance to next entity\n    let nextIndex = combatState.turnIndex + 1;\n    let nextRound = combatState.round;\n\n    if (nextIndex >= combatState.initiativeOrder.length) {\n      nextIndex = 0;\n      nextRound += 1;\n\n      // Reset reactions for all entities at round start\n      for (const entity of Object.values(combatState.entities)) {\n        entity.reaction.available = true;\n      }\n\n      combatState.log.push(this.createAuthLogEntry(\"round_started\", undefined, undefined, {\n        round: nextRound,\n      }));\n    }\n\n    combatState.turnIndex = nextIndex;\n    combatState.round = nextRound;\n    combatState.activeEntityId = combatState.initiativeOrder[nextIndex] ?? null;\n    combatState.phase = \"active-turn\";\n\n    // Reset AP for new active entity\n    if (combatState.activeEntityId) {\n      const activeEntity = combatState.entities[combatState.activeEntityId];\n      if (activeEntity) {\n        activeEntity.ap.current = activeEntity.ap.max;\n\n        combatState.log.push(this.createAuthLogEntry(\"turn_started\", combatState.activeEntityId, undefined, {\n          round: combatState.round,\n          turnIndex: combatState.turnIndex,\n          apRestored: activeEntity.ap.max,\n        }));\n      }\n    }\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n    this.broadcastAuthEvent(\"TURN_ENDED\", campaignId, sequence, {\n      entityId: previousEntityId ?? entityId,\n      entityName: previousEntity?.displayName || previousEntity?.name || \"Unknown\",\n      reason: body.voluntary === false ? \"no_ap\" : \"voluntary\",\n      energyGained: 0,\n    });\n    this.broadcastAuthEvent(\"STATE_SYNC\", campaignId, sequence, {\n      state: combatState,\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState }, 200, {}, request);\n  }\n\n  // Handler: GM Override\n  private async handleGmOverride(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const gmId = parseRequiredStringField(body.gmId, \"gmId\", request);\n    if (gmId instanceof Response) return gmId;\n\n    const overrideType = body.type as GmOverrideType;\n    if (!overrideType) {\n      return jsonResponse({ error: \"Override type required.\" }, 400, {}, request);\n    }\n\n    const targetEntityId = parseStringField(body.targetEntityId, \"targetEntityId\", false, request);\n    if (targetEntityId instanceof Response) return targetEntityId;\n\n    const reason = parseStringField(body.reason, \"reason\", false, request);\n    if (reason instanceof Response) return reason;\n\n    const override: GmOverride = {\n      type: overrideType,\n      gmId,\n      targetEntityId: targetEntityId ?? undefined,\n      data: body.data as Record<string, unknown> | undefined,\n      reason: reason ?? undefined,\n      timestamp: new Date().toISOString(),\n    };\n\n    // Apply the override\n    switch (overrideType) {\n      case \"adjust_ap\":\n        if (targetEntityId && combatState.entities[targetEntityId]) {\n          const delta = parseNumberField(body.data?.delta ?? body.data?.amount, \"delta\", 0, request);\n          if (typeof delta === \"number\") {\n            const entity = combatState.entities[targetEntityId];\n            entity.ap.current = Math.max(0, Math.min(entity.ap.max, entity.ap.current + delta));\n          }\n        }\n        break;\n\n      case \"adjust_energy\":\n        if (targetEntityId && combatState.entities[targetEntityId]) {\n          const delta = parseNumberField(body.data?.delta ?? body.data?.amount, \"delta\", 0, request);\n          if (typeof delta === \"number\") {\n            const entity = combatState.entities[targetEntityId];\n            entity.energy.current = Math.max(0, Math.min(entity.energy.max, entity.energy.current + delta));\n          }\n        }\n        break;\n\n      case \"skip_entity\":\n        if (combatState.activeEntityId === targetEntityId) {\n          // Force end turn for this entity\n          const nextIndex = (combatState.turnIndex + 1) % combatState.initiativeOrder.length;\n          if (nextIndex < combatState.turnIndex) {\n            combatState.round += 1;\n          }\n          combatState.turnIndex = nextIndex;\n          combatState.activeEntityId = combatState.initiativeOrder[nextIndex] ?? null;\n        }\n        break;\n\n      case \"end_turn\":\n        // Just advance the turn\n        const nextIdx = (combatState.turnIndex + 1) % combatState.initiativeOrder.length;\n        if (nextIdx < combatState.turnIndex) {\n          combatState.round += 1;\n          for (const entity of Object.values(combatState.entities)) {\n            entity.reaction.available = true;\n          }\n        }\n        combatState.turnIndex = nextIdx;\n        combatState.activeEntityId = combatState.initiativeOrder[nextIdx] ?? null;\n        if (combatState.activeEntityId) {\n          const activeEntity = combatState.entities[combatState.activeEntityId];\n          if (activeEntity) {\n            activeEntity.ap.current = activeEntity.ap.max;\n          }\n        }\n        break;\n\n      case \"modify_initiative\":\n        if (Array.isArray(body.data?.newOrder)) {\n          combatState.initiativeOrder = body.data.newOrder as string[];\n        }\n        break;\n\n      case \"add_status\":\n        if (targetEntityId && combatState.entities[targetEntityId] && body.data?.statusKey) {\n          combatState.entities[targetEntityId].statusEffects.push({\n            key: body.data.statusKey as string,\n            stacks: (body.data.stacks as number) ?? 1,\n            duration: (body.data.duration as number) ?? null,\n          });\n        }\n        break;\n\n      case \"remove_status\":\n        if (targetEntityId && combatState.entities[targetEntityId] && body.data?.statusKey) {\n          combatState.entities[targetEntityId].statusEffects =\n            combatState.entities[targetEntityId].statusEffects.filter(\n              s => s.key !== body.data?.statusKey\n            );\n        }\n        break;\n\n      case \"modify_wounds\":\n        if (targetEntityId && combatState.entities[targetEntityId]) {\n          if (body.data?.wounds) {\n            const wounds = body.data.wounds as WoundCounts;\n            for (const [woundType, count] of Object.entries(wounds)) {\n              combatState.entities[targetEntityId].wounds[woundType as WoundType] = count as number;\n            }\n          } else if (body.data?.woundType && body.data?.count !== undefined) {\n            combatState.entities[targetEntityId].wounds[body.data.woundType as WoundType] =\n              body.data.count as number;\n          }\n        }\n        break;\n\n      case \"set_phase\":\n        if (body.data?.phase) {\n          combatState.phase = body.data.phase as CombatPhase;\n        }\n        break;\n\n      case \"cancel_reaction\":\n        if (body.data?.reactionId) {\n          combatState.pendingReactions = combatState.pendingReactions.filter(\n            r => r.reactionId !== body.data?.reactionId\n          );\n        }\n        break;\n\n      case \"end_combat\":\n        combatState.phase = \"completed\";\n        break;\n    }\n\n    // Log the override\n    combatState.log.push(this.createAuthLogEntry(\"gm_override\", undefined, targetEntityId ?? undefined, {\n      overrideType,\n      gmId,\n      reason: reason ?? undefined,\n      data: body.data,\n    }));\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n    this.broadcastAuthEvent(\"GM_OVERRIDE\", campaignId, sequence, {\n      override,\n      state: combatState,\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState, override }, 200, {}, request);\n  }\n\n  // Handler: End combat\n  private async handleEndCombat(campaignId: string, body: unknown, request: Request): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const reason = (body.reason as \"victory\" | \"defeat\" | \"gm_ended\") ?? \"gm_ended\";\n\n    combatState.phase = \"completed\";\n    combatState.pendingAction = null;\n    combatState.pendingReactions = [];\n\n    combatState.log.push(this.createAuthLogEntry(\"combat_ended\", undefined, undefined, {\n      reason,\n      round: combatState.round,\n      turnIndex: combatState.turnIndex,\n    }));\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n    this.broadcastAuthEvent(\"COMBAT_ENDED\", campaignId, sequence, {\n      combatId: combatState.combatId,\n      reason,\n      finalLog: combatState.log,\n      state: combatState,\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState, reason }, 200, {}, request);\n  }\n\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // SKILL CONTEST HANDLERS\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n  private async handleInitiateSkillContest(\n    campaignId: string,\n    body: unknown,\n    request: Request\n  ): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const initiatorEntityId = parseRequiredStringField(body.initiatorEntityId, \"initiatorEntityId\", request);\n    if (initiatorEntityId instanceof Response) return initiatorEntityId;\n\n    const targetEntityId = parseRequiredStringField(body.targetEntityId, \"targetEntityId\", request);\n    if (targetEntityId instanceof Response) return targetEntityId;\n\n    const skill = parseRequiredStringField(body.skill, \"skill\", request);\n    if (skill instanceof Response) return skill;\n\n    const initiator = combatState.entities[initiatorEntityId];\n    const target = combatState.entities[targetEntityId];\n\n    if (!initiator) {\n      return jsonResponse({ error: \"Initiator entity not found.\" }, 404, {}, request);\n    }\n    if (!target) {\n      return jsonResponse({ error: \"Target entity not found.\" }, 404, {}, request);\n    }\n\n    // Validate and convert roll\n    const roll = body.roll;\n    if (!isRecord(roll)) {\n      return jsonResponse({ error: \"Invalid roll data.\" }, 400, {}, request);\n    }\n\n    const skillModifier = initiator.skills[skill] ?? 0;\n    const rollData = this.validateAndConvertRoll(roll as DiceRoll, skill, skillModifier, request);\n    if (rollData instanceof Response) return rollData;\n\n    // Create contest\n    const contestId = crypto.randomUUID();\n    const contest: SkillContestRequest = {\n      contestId,\n      initiatorId: initiatorEntityId,\n      initiatorSkill: skill,\n      initiatorRoll: rollData,\n      targetId: targetEntityId,\n      autoRollDefense: target.autoRollDefense ?? false,\n      status: \"awaiting_defense\",\n      createdAt: new Date().toISOString(),\n    };\n\n    combatState.pendingSkillContests[contestId] = contest;\n\n    // If auto-roll defense, resolve immediately\n    if (contest.autoRollDefense && target.defaultDefenseSkill) {\n      return this.autoResolveContest(campaignId, combatState, contest, target, request);\n    }\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n\n    // Broadcast to all players\n    this.broadcastAuthEvent(\"SKILL_CONTEST_INITIATED\", campaignId, sequence, {\n      contest,\n      initiatorName: initiator.displayName || initiator.name,\n      targetName: target.displayName || target.name,\n    });\n\n    // Send specific notification to target player\n    if (target.controller.startsWith(\"player:\")) {\n      const targetPlayerId = target.controller.replace(\"player:\", \"\");\n      this.broadcastAuthEvent(\"SKILL_CONTEST_DEFENSE_REQUESTED\", campaignId, sequence, {\n        contestId,\n        targetEntityId,\n        targetPlayerId,\n        initiatorName: initiator.displayName || initiator.name,\n        initiatorSkill: skill,\n        initiatorTotal: rollData.total,\n      });\n    }\n\n    return jsonResponse({ ok: true, sequence, state: combatState, contestId }, 200, {}, request);\n  }\n\n  private async handleRespondSkillContest(\n    campaignId: string,\n    body: unknown,\n    request: Request\n  ): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const contestId = parseRequiredStringField(body.contestId, \"contestId\", request);\n    if (contestId instanceof Response) return contestId;\n\n    const entityId = parseRequiredStringField(body.entityId, \"entityId\", request);\n    if (entityId instanceof Response) return entityId;\n\n    const skill = parseRequiredStringField(body.skill, \"skill\", request);\n    if (skill instanceof Response) return skill;\n\n    const contest = combatState.pendingSkillContests[contestId];\n    if (!contest) {\n      return jsonResponse({ error: \"Contest not found.\" }, 404, {}, request);\n    }\n\n    if (contest.status !== \"awaiting_defense\") {\n      return jsonResponse({ error: \"Contest already resolved.\" }, 400, {}, request);\n    }\n\n    const defender = combatState.entities[entityId];\n    if (!defender) {\n      return jsonResponse({ error: \"Defender entity not found.\" }, 404, {}, request);\n    }\n\n    // Validate and convert roll\n    const roll = body.roll;\n    if (!isRecord(roll)) {\n      return jsonResponse({ error: \"Invalid roll data.\" }, 400, {}, request);\n    }\n\n    const skillModifier = defender.skills[skill] ?? 0;\n    const rollData = this.validateAndConvertRoll(roll as DiceRoll, skill, skillModifier, request);\n    if (rollData instanceof Response) return rollData;\n\n    // Resolve contest\n    const outcome = this.resolveSkillContest(contest.initiatorRoll, rollData);\n    contest.defenderSkill = skill;\n    contest.defenderRoll = rollData;\n    contest.outcome = outcome;\n    contest.status = \"resolved\";\n    contest.resolvedAt = new Date().toISOString();\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n\n    const initiator = combatState.entities[contest.initiatorId];\n    const audit = `${initiator.displayName || initiator.name} (${contest.initiatorRoll.total}) vs ${defender.displayName || defender.name} (${rollData.total}) - ${outcome.isTie ? \"TIE\" : (outcome.winnerId === \"initiator\" ? \"Initiator wins\" : \"Defender wins\")} [${outcome.criticalTier.toUpperCase()}]`;\n\n    this.broadcastAuthEvent(\"SKILL_CONTEST_RESOLVED\", campaignId, sequence, {\n      contest,\n      outcome,\n      initiatorName: initiator.displayName || initiator.name,\n      targetName: defender.displayName || defender.name,\n      audit,\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState, outcome }, 200, {}, request);\n  }\n\n  private async handleRequestSkillCheck(\n    campaignId: string,\n    body: unknown,\n    request: Request\n  ): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const targetPlayerId = parseRequiredStringField(body.targetPlayerId, \"targetPlayerId\", request);\n    if (targetPlayerId instanceof Response) return targetPlayerId;\n\n    const targetEntityId = parseRequiredStringField(body.targetEntityId, \"targetEntityId\", request);\n    if (targetEntityId instanceof Response) return targetEntityId;\n\n    const skill = parseRequiredStringField(body.skill, \"skill\", request);\n    if (skill instanceof Response) return skill;\n\n    const targetNumber = body.targetNumber !== undefined ? parseNumberField(body.targetNumber, \"targetNumber\", undefined, request) : undefined;\n\n    const entity = combatState.entities[targetEntityId];\n    if (!entity) {\n      return jsonResponse({ error: \"Entity not found.\" }, 404, {}, request);\n    }\n\n    // Create skill check request\n    const checkId = crypto.randomUUID();\n    const check: SkillCheckRequest = {\n      checkId,\n      requesterId: \"gm\", // Always GM for now\n      targetPlayerId,\n      targetEntityId,\n      skill,\n      targetNumber: typeof targetNumber === \"number\" ? targetNumber : undefined,\n      status: \"pending\",\n      createdAt: new Date().toISOString(),\n    };\n\n    combatState.pendingSkillChecks[checkId] = check;\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n\n    this.broadcastAuthEvent(\"SKILL_CHECK_REQUESTED\", campaignId, sequence, {\n      check,\n      targetPlayerName: targetPlayerId,\n      entityName: entity.displayName || entity.name,\n      skill,\n      targetNumber, // Only GM sees this\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState, checkId }, 200, {}, request);\n  }\n\n  private async handleSubmitSkillCheck(\n    campaignId: string,\n    body: unknown,\n    request: Request\n  ): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const checkId = parseRequiredStringField(body.checkId, \"checkId\", request);\n    if (checkId instanceof Response) return checkId;\n\n    const check = combatState.pendingSkillChecks[checkId];\n    if (!check) {\n      return jsonResponse({ error: \"Skill check not found.\" }, 404, {}, request);\n    }\n\n    if (check.status !== \"pending\") {\n      return jsonResponse({ error: \"Skill check already completed.\" }, 400, {}, request);\n    }\n\n    const entity = combatState.entities[check.targetEntityId];\n    if (!entity) {\n      return jsonResponse({ error: \"Entity not found.\" }, 404, {}, request);\n    }\n\n    // Validate and convert roll\n    const roll = body.roll;\n    if (!isRecord(roll)) {\n      return jsonResponse({ error: \"Invalid roll data.\" }, 400, {}, request);\n    }\n\n    const skillModifier = entity.skills[check.skill] ?? 0;\n    const rollData = this.validateAndConvertRoll(roll as DiceRoll, check.skill, skillModifier, request);\n    if (rollData instanceof Response) return rollData;\n\n    check.rollData = rollData;\n    check.status = \"rolled\";\n    check.resolvedAt = new Date().toISOString();\n\n    const success = check.targetNumber !== undefined ? rollData.total >= check.targetNumber : undefined;\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n\n    this.broadcastAuthEvent(\"SKILL_CHECK_ROLLED\", campaignId, sequence, {\n      check,\n      rollData,\n      success,\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState, rollData, success }, 200, {}, request);\n  }\n\n  private async handleRemoveEntity(\n    campaignId: string,\n    body: unknown,\n    request: Request\n  ): Promise<Response> {\n    if (!isRecord(body)) {\n      return jsonResponse({ error: \"Invalid payload.\" }, 400, {}, request);\n    }\n\n    const combatState = await this.loadAuthCombatState(campaignId);\n    if (!combatState) {\n      return jsonResponse({ error: \"Combat state not found.\" }, 404, {}, request);\n    }\n\n    const entityId = parseRequiredStringField(body.entityId, \"entityId\", request);\n    if (entityId instanceof Response) return entityId;\n\n    const entity = combatState.entities[entityId];\n    if (!entity) {\n      return jsonResponse({ error: \"Entity not found.\" }, 404, {}, request);\n    }\n\n    // Can't remove active entity\n    if (combatState.activeEntityId === entityId) {\n      return jsonResponse({ error: \"Cannot remove active entity. End their turn first.\" }, 400, {}, request);\n    }\n\n    const reason = (body.reason as \"gm_removed\" | \"defeated\" | \"fled\") ?? \"gm_removed\";\n    const entityName = entity.displayName || entity.name;\n\n    // Remove from entities\n    delete combatState.entities[entityId];\n\n    // Remove from initiative order\n    combatState.initiativeOrder = combatState.initiativeOrder.filter(id => id !== entityId);\n\n    // Remove from grid\n    combatState.grid.allies = combatState.grid.allies.filter(id => id !== entityId);\n    combatState.grid.enemies = combatState.grid.enemies.filter(id => id !== entityId);\n\n    // Adjust turn index if needed\n    const removedIndex = combatState.initiativeOrder.indexOf(entityId);\n    if (removedIndex !== -1 && removedIndex < combatState.turnIndex) {\n      combatState.turnIndex = Math.max(0, combatState.turnIndex - 1);\n    }\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n\n    this.broadcastAuthEvent(\"ENTITY_REMOVED\", campaignId, sequence, {\n      entityId,\n      entityName,\n      reason,\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState }, 200, {}, request);\n  }\n\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // SKILL CONTEST HELPER METHODS\n  // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n  private calculateCriticalTier(winnerTotal: number, loserTotal: number): CriticalTier {\n    if (loserTotal <= 0) return \"brutal\";\n    const ratio = winnerTotal / loserTotal;\n    if (ratio >= 3.0) return \"brutal\";   // 200%+ higher\n    if (ratio >= 2.0) return \"vicious\";  // 100%+ higher\n    if (ratio >= 1.5) return \"wicked\";   // 50%+ higher\n    return \"normal\";\n  }\n\n  private resolveSkillContest(initiatorRoll: RollData, defenderRoll: RollData): ContestOutcome {\n    const initiatorTotal = initiatorRoll.total;\n    const defenderTotal = defenderRoll.total;\n\n    if (initiatorTotal === defenderTotal) {\n      return {\n        winnerId: null,\n        loserId: null,\n        winnerTotal: initiatorTotal,\n        loserTotal: defenderTotal,\n        criticalTier: \"normal\",\n        isTie: true,\n      };\n    }\n\n    const initiatorWins = initiatorTotal > defenderTotal;\n    const winnerTotal = initiatorWins ? initiatorTotal : defenderTotal;\n    const loserTotal = initiatorWins ? defenderTotal : initiatorTotal;\n\n    return {\n      winnerId: initiatorWins ? \"initiator\" : \"defender\",\n      loserId: initiatorWins ? \"defender\" : \"initiator\",\n      winnerTotal,\n      loserTotal,\n      criticalTier: this.calculateCriticalTier(winnerTotal, loserTotal),\n      isTie: false,\n    };\n  }\n\n  private async autoResolveContest(\n    campaignId: string,\n    combatState: AuthoritativeCombatState,\n    contest: SkillContestRequest,\n    defender: CombatEntity,\n    request: Request\n  ): Promise<Response> {\n    const defenseSkill = defender.defaultDefenseSkill!;\n    const skillModifier = defender.skills[defenseSkill] ?? 0;\n\n    // Auto-roll d100 for defense\n    const diceRoll = Math.floor(Math.random() * 100) + 1;\n    const defenderRoll: RollData = {\n      skill: defenseSkill,\n      modifier: skillModifier,\n      diceCount: 1,\n      keepHighest: true,\n      rawDice: [diceRoll],\n      selectedDie: diceRoll,\n      total: diceRoll + skillModifier,\n      audit: `1d100 [${diceRoll}] + ${skillModifier} = ${diceRoll + skillModifier}`,\n    };\n\n    // Resolve contest\n    const outcome = this.resolveSkillContest(contest.initiatorRoll, defenderRoll);\n    contest.defenderSkill = defenseSkill;\n    contest.defenderRoll = defenderRoll;\n    contest.outcome = outcome;\n    contest.status = \"resolved\";\n    contest.resolvedAt = new Date().toISOString();\n\n    const sequence = await this.saveAuthCombatState(campaignId, combatState);\n\n    const initiator = combatState.entities[contest.initiatorId];\n    const audit = `${initiator.displayName || initiator.name} (${contest.initiatorRoll.total}) vs ${defender.displayName || defender.name} (${defenderRoll.total}) [AUTO] - ${outcome.isTie ? \"TIE\" : (outcome.winnerId === \"initiator\" ? \"Initiator wins\" : \"Defender wins\")} [${outcome.criticalTier.toUpperCase()}]`;\n\n    this.broadcastAuthEvent(\"SKILL_CONTEST_RESOLVED\", campaignId, sequence, {\n      contest,\n      outcome,\n      initiatorName: initiator.displayName || initiator.name,\n      targetName: defender.displayName || defender.name,\n      audit,\n    });\n\n    return jsonResponse({ ok: true, sequence, state: combatState, outcome }, 200, {}, request);\n  }\n\n  private assignMonsterDisplayNames(entities: Record<string, CombatEntity>): Record<string, CombatEntity> {\n    const result: Record<string, CombatEntity> = {};\n    const nameCounts: Record<string, number> = {};\n\n    // First pass: count how many of each monster name\n    const monsterCounts: Record<string, number> = {};\n    for (const entity of Object.values(entities)) {\n      if (entity.controller === \"gm\") {\n        const baseName = entity.baseNameForNumbering ?? entity.name;\n        monsterCounts[baseName] = (monsterCounts[baseName] ?? 0) + 1;\n      }\n    }\n\n    // Second pass: assign display names\n    for (const [id, entity] of Object.entries(entities)) {\n      if (entity.controller === \"gm\") {\n        const baseName = entity.baseNameForNumbering ?? entity.name;\n        const count = (nameCounts[baseName] ?? 0) + 1;\n        nameCounts[baseName] = count;\n\n        result[id] = {\n          ...entity,\n          baseNameForNumbering: baseName,\n          displayName: monsterCounts[baseName] > 1 ? `${baseName} ${count}` : baseName,\n        };\n      } else {\n        result[id] = entity;\n      }\n    }\n\n    return result;\n  }\n\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  // END AUTHORITATIVE COMBAT SYSTEM\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n  private broadcast(event: CampaignEvent) {\n    const message = JSON.stringify(event);\n    for (const [connectionId, socket] of this.sessions) {\n      try {\n        socket.send(message);\n      } catch {\n        socket.close();\n        this.sessions.delete(connectionId);\n        this.presence.delete(connectionId);\n      }\n    }\n  }\n\n  private currentPresence(): PresenceEntry[] {\n    return Array.from(this.presence.keys()).map((connectionId) =>\n      this.serializePresence(connectionId),\n    );\n  }\n\n  private serializePresence(connectionId: string): PresenceEntry {\n    const presence = this.presence.get(connectionId);\n    return {\n      connectionId,\n      userId: presence?.userId ?? connectionId,\n      connectedAt: presence?.connectedAt ?? new Date().toISOString(),\n    };\n  }\n\n  private rollRequestKey(requestId: string) {\n    return `roll_request:${requestId}`;\n  }\n\n  private rollContestKey(contestId: string) {\n    return `roll_contest:${contestId}`;\n  }\n\n  private supabaseConfig(): { url: string; key: string } | Response {\n    if (!this.env.SUPABASE_URL || !this.env.SUPABASE_SERVICE_ROLE_KEY) {\n      return jsonResponse({ error: \"Supabase configuration missing.\" }, 500);\n    }\n\n    return { url: this.env.SUPABASE_URL, key: this.env.SUPABASE_SERVICE_ROLE_KEY };\n  }\n\n  private async persistSupabase(\n    table: \"roll_requests\" | \"roll_contests\",\n    payload: Record<string, unknown>,\n    options?: { upsert?: boolean },\n  ): Promise<Response | null> {\n    const config = this.supabaseConfig();\n    if (config instanceof Response) {\n      return config;\n    }\n\n    const url = new URL(`/rest/v1/${table}`, config.url);\n    if (options?.upsert) {\n      url.searchParams.set(\"on_conflict\", \"id\");\n    }\n    const response = await fetch(url.toString(), {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n        apikey: config.key,\n        authorization: `Bearer ${config.key}`,\n        Prefer: options?.upsert\n          ? \"resolution=merge-duplicates, return=minimal\"\n          : \"return=minimal\",\n      },\n      body: JSON.stringify(payload),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      return jsonResponse(\n        { error: `Supabase insert failed for ${table}.`, details: errorText },\n        500,\n      );\n    }\n\n    return null;\n  }\n\n  private async loadCombatantsFromSupabase(\n    campaignId: string,\n  ): Promise<CombatantStartPayload[] | Response> {\n    const config = this.supabaseConfig();\n    if (config instanceof Response) {\n      return config;\n    }\n\n    const headers = {\n      apikey: config.key,\n      authorization: `Bearer ${config.key}`,\n    };\n\n    const combatantsUrl = new URL(\"/rest/v1/campaign_combatants\", config.url);\n    combatantsUrl.searchParams.set(\n      \"select\",\n      \"id,initiative,ap_max,energy_max,ap_current,energy_current,is_active\",\n    );\n    combatantsUrl.searchParams.set(\"campaign_id\", `eq.${campaignId}`);\n    combatantsUrl.searchParams.set(\"is_active\", \"eq.true\");\n\n    const statusUrl = new URL(\"/rest/v1/campaign_combatant_status_effects\", config.url);\n    statusUrl.searchParams.set(\"select\", \"combatant_id,status_key,is_active\");\n    statusUrl.searchParams.set(\"campaign_id\", `eq.${campaignId}`);\n\n    const woundsUrl = new URL(\"/rest/v1/campaign_combatant_wounds\", config.url);\n    woundsUrl.searchParams.set(\"select\", \"combatant_id,wound_count\");\n    woundsUrl.searchParams.set(\"campaign_id\", `eq.${campaignId}`);\n\n    const [combatantRes, statusRes, woundsRes] = await Promise.all([\n      fetch(combatantsUrl.toString(), { headers }),\n      fetch(statusUrl.toString(), { headers }),\n      fetch(woundsUrl.toString(), { headers }),\n    ]);\n\n    if (!combatantRes.ok) {\n      const details = await combatantRes.text();\n      return jsonResponse(\n        { error: \"Failed to load combatants from Supabase.\", details },\n        500,\n      );\n    }\n    if (!statusRes.ok) {\n      const details = await statusRes.text();\n      return jsonResponse(\n        { error: \"Failed to load combatant status effects from Supabase.\", details },\n        500,\n      );\n    }\n    if (!woundsRes.ok) {\n      const details = await woundsRes.text();\n      return jsonResponse(\n        { error: \"Failed to load combatant wounds from Supabase.\", details },\n        500,\n      );\n    }\n\n    const combatantRows = (await combatantRes.json()) as {\n      id: string;\n      initiative?: number | null;\n      ap_max?: number | null;\n      energy_max?: number | null;\n      ap_current?: number | null;\n      energy_current?: number | null;\n      is_active?: boolean | null;\n    }[];\n    const statusRows = (await statusRes.json()) as {\n      combatant_id: string;\n      status_key: string;\n      is_active?: boolean | null;\n    }[];\n    const woundRows = (await woundsRes.json()) as {\n      combatant_id: string;\n      wound_count?: number | null;\n    }[];\n\n    const statusById = new Map<string, string[]>();\n    statusRows.forEach((row) => {\n      if (row.is_active === false) return;\n      const list = statusById.get(row.combatant_id) ?? [];\n      list.push(row.status_key);\n      statusById.set(row.combatant_id, list);\n    });\n\n    const woundsById = new Map<string, number>();\n    woundRows.forEach((row) => {\n      const current = woundsById.get(row.combatant_id) ?? 0;\n      const increment = typeof row.wound_count === \"number\" ? row.wound_count : 0;\n      woundsById.set(row.combatant_id, current + increment);\n    });\n\n    const readNumber = (value?: number | null) =>\n      typeof value === \"number\" && Number.isFinite(value) ? value : 0;\n\n    return combatantRows.map((row) => ({\n      id: row.id,\n      initiative: readNumber(row.initiative),\n      actionPoints:\n        typeof row.ap_max === \"number\" && Number.isFinite(row.ap_max)\n          ? row.ap_max\n          : readNumber(row.ap_current),\n      energy:\n        typeof row.energy_max === \"number\" && Number.isFinite(row.energy_max)\n          ? row.energy_max\n          : readNumber(row.energy_current),\n      statusEffects: statusById.get(row.id) ?? [],\n      wounds: woundsById.get(row.id) ?? 0,\n    }));\n  }\n}\n\nfunction jsonResponse(body: unknown, status = 200, headers?: HeadersInit, request?: Request) {\n  const corsHeaders = request ? getCorsHeaders(request) : {};\n  return new Response(JSON.stringify(body), {\n    status,\n    headers: {\n      \"content-type\": \"application/json\",\n      ...corsHeaders,\n      ...headers,\n    },\n  });\n}\n\nasync function readJsonBody(request: Request): Promise<unknown | Response> {\n  if (!request.headers.get(\"content-type\")?.includes(\"application/json\")) {\n    return jsonResponse({ error: \"Expected JSON body\" }, 415, {}, request);\n  }\n\n  try {\n    return await request.json();\n  } catch {\n    return jsonResponse({ error: \"Invalid JSON\" }, 400, {}, request);\n  }\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null;\n}\n\nfunction parseStringField(\n  value: unknown,\n  field: string,\n  required = false,\n  request?: Request,\n): string | Response | undefined {\n  if (value == null) {\n    if (required) {\n      return jsonResponse({ error: `Missing ${field}.` }, 400, {}, request);\n    }\n    return undefined;\n  }\n\n  if (typeof value !== \"string\" || value.trim().length === 0) {\n    return jsonResponse({ error: `Invalid ${field}.` }, 400, {}, request);\n  }\n\n  return value;\n}\n\nfunction parseRequiredStringField(value: unknown, field: string, request?: Request): string | Response {\n  const parsed = parseStringField(value, field, true, request);\n  if (parsed instanceof Response) {\n    return parsed;\n  }\n  return parsed as string;\n}\n\nfunction parseNumberField(\n  value: unknown,\n  field: string,\n  fallback = 0,\n  request?: Request,\n): number | Response {\n  if (value == null) {\n    return fallback;\n  }\n\n  if (typeof value === \"number\" && Number.isFinite(value)) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    const parsed = Number(value);\n    if (Number.isFinite(parsed)) {\n      return parsed;\n    }\n  }\n\n  return jsonResponse({ error: `Invalid ${field}.` }, 400, {}, request);\n}\n\nfunction parseBooleanField(\n  value: unknown,\n  field: string,\n  fallback = false,\n  request?: Request,\n): boolean | Response {\n  if (value == null) {\n    return fallback;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  return jsonResponse({ error: `Invalid ${field}.` }, 400, {}, request);\n}\n\nfunction parseStringArrayField(\n  value: unknown,\n  field: string,\n  request?: Request,\n): string[] | Response | undefined {\n  if (value == null) {\n    return undefined;\n  }\n  if (!Array.isArray(value)) {\n    return jsonResponse({ error: `Invalid ${field}.` }, 400, {}, request);\n  }\n  for (const entry of value) {\n    if (typeof entry !== \"string\") {\n      return jsonResponse({ error: `Invalid ${field}.` }, 400, {}, request);\n    }\n  }\n  return value;\n}\n\nfunction parseCombatStart(body: unknown): CombatStartPayload | Response {\n  if (!isRecord(body)) {\n    return jsonResponse({ error: \"Invalid payload.\" }, 400);\n  }\n\n  if (body.combatants != null && !Array.isArray(body.combatants)) {\n    return jsonResponse({ error: \"Invalid combatants.\" }, 400);\n  }\n\n  const groupInitiative = parseBooleanField(body.groupInitiative, \"groupInitiative\");\n  if (groupInitiative instanceof Response) {\n    return groupInitiative;\n  }\n\n  const ambushedIds = parseStringArrayField(body.ambushedIds, \"ambushedIds\");\n  if (ambushedIds instanceof Response) {\n    return ambushedIds;\n  }\n\n  const combatants: CombatantStartPayload[] = [];\n\n  for (const entry of body.combatants ?? []) {\n    if (!isRecord(entry)) {\n      return jsonResponse({ error: \"Invalid combatant entry.\" }, 400);\n    }\n    const id = parseRequiredStringField(entry.id, \"combatants.id\");\n    if (id instanceof Response) {\n      return id;\n    }\n    const initiative = parseNumberField(entry.initiative, \"combatants.initiative\");\n    if (initiative instanceof Response) {\n      return initiative;\n    }\n    const initiativeRoll = parseNumberField(entry.initiativeRoll, \"combatants.initiativeRoll\");\n    if (initiativeRoll instanceof Response) {\n      return initiativeRoll;\n    }\n    const initiativeBonus = parseNumberField(\n      entry.initiativeBonus,\n      \"combatants.initiativeBonus\",\n    );\n    if (initiativeBonus instanceof Response) {\n      return initiativeBonus;\n    }\n    const actionPoints = parseNumberField(entry.actionPoints, \"combatants.actionPoints\");\n    if (actionPoints instanceof Response) {\n      return actionPoints;\n    }\n    const energy = parseNumberField(entry.energy, \"combatants.energy\");\n    if (energy instanceof Response) {\n      return energy;\n    }\n    const wounds = parseNumberField(entry.wounds, \"combatants.wounds\");\n    if (wounds instanceof Response) {\n      return wounds;\n    }\n    const statusEffects = parseStringArrayField(\n      entry.statusEffects,\n      \"combatants.statusEffects\",\n    );\n    if (statusEffects instanceof Response) {\n      return statusEffects;\n    }\n    const groupId = parseStringField(entry.groupId, \"combatants.groupId\");\n    if (groupId instanceof Response) {\n      return groupId;\n    }\n    const ambushed = parseBooleanField(entry.ambushed, \"combatants.ambushed\");\n    if (ambushed instanceof Response) {\n      return ambushed;\n    }\n\n    combatants.push({\n      id,\n      initiative,\n      initiativeRoll,\n      initiativeBonus,\n      actionPoints,\n      energy,\n      statusEffects,\n      wounds,\n      ambushed,\n      groupId,\n    });\n  }\n\n  return {\n    combatants,\n    groupInitiative,\n    ambushedIds,\n  };\n}\n\nfunction parseCombatAdvance(body: unknown): CombatAdvancePayload | Response {\n  if (!isRecord(body)) {\n    return jsonResponse({ error: \"Invalid payload.\" }, 400);\n  }\n\n  let statusEffectsById: Record<string, string[]> | undefined;\n  if (body.statusEffectsById != null) {\n    if (!isRecord(body.statusEffectsById)) {\n      return jsonResponse({ error: \"Invalid statusEffectsById.\" }, 400);\n    }\n    statusEffectsById = {};\n    for (const [combatantId, statusList] of Object.entries(body.statusEffectsById)) {\n      const parsed = parseStringArrayField(statusList, \"statusEffectsById\");\n      if (parsed instanceof Response) {\n        return parsed;\n      }\n      statusEffectsById[combatantId] = parsed ?? [];\n    }\n  }\n\n  return { statusEffectsById };\n}\n\nfunction parseCombatAmbush(body: unknown): CombatAmbushPayload | Response {\n  if (!isRecord(body)) {\n    return jsonResponse({ error: \"Invalid payload.\" }, 400);\n  }\n\n  const combatantId = parseStringField(body.combatantId, \"combatantId\");\n  if (combatantId instanceof Response) {\n    return combatantId;\n  }\n\n  return { combatantId };\n}\n\nfunction parseCombatSpend(body: unknown): CombatSpendPayload | Response {\n  if (!isRecord(body)) {\n    return jsonResponse({ error: \"Invalid payload.\" }, 400);\n  }\n\n  const combatantId = parseRequiredStringField(body.combatantId, \"combatantId\");\n  if (combatantId instanceof Response) {\n    return combatantId;\n  }\n  const actionPointCost = parseNumberField(body.actionPointCost, \"actionPointCost\");\n  if (actionPointCost instanceof Response) {\n    return actionPointCost;\n  }\n  const energyCost = parseNumberField(body.energyCost, \"energyCost\");\n  if (energyCost instanceof Response) {\n    return energyCost;\n  }\n  const actionType = parseStringField(body.actionType, \"actionType\");\n  if (actionType instanceof Response) {\n    return actionType;\n  }\n  const targetId = parseStringField(body.targetId, \"targetId\");\n  if (targetId instanceof Response) {\n    return targetId;\n  }\n  const rollResults = body.rollResults;\n  const metadata = body.metadata;\n\n  return {\n    combatantId,\n    actionPointCost,\n    energyCost,\n    actionType,\n    targetId,\n    rollResults,\n    metadata,\n  };\n}\n\nfunction parseCombatReaction(body: unknown): CombatReactionPayload | Response {\n  if (!isRecord(body)) {\n    return jsonResponse({ error: \"Invalid payload.\" }, 400);\n  }\n\n  const combatantId = parseRequiredStringField(body.combatantId, \"combatantId\");\n  if (combatantId instanceof Response) {\n    return combatantId;\n  }\n  const actionPointCost = parseNumberField(body.actionPointCost, \"actionPointCost\");\n  if (actionPointCost instanceof Response) {\n    return actionPointCost;\n  }\n  const reactionType = parseStringField(body.reactionType, \"reactionType\");\n  if (reactionType instanceof Response) {\n    return reactionType;\n  }\n  const metadata = body.metadata;\n\n  return {\n    combatantId,\n    actionPointCost,\n    reactionType,\n    metadata,\n  };\n}\n\nfunction createCombatEventLogEntry(type: CombatEventType, payload?: unknown): CombatEventLogEntry {\n  return {\n    id: crypto.randomUUID(),\n    type,\n    timestamp: new Date().toISOString(),\n    payload,\n  };\n}\n\nfunction parseRollRequest(body: unknown): RollRequestPayload | Response {\n  if (!isRecord(body)) {\n    return jsonResponse({ error: \"Invalid payload.\" }, 400);\n  }\n\n  const playerId = parseRequiredStringField(body.playerId, \"playerId\");\n  if (playerId instanceof Response) {\n    return playerId;\n  }\n\n  const modifier = parseNumberField(body.modifier, \"modifier\");\n  if (modifier instanceof Response) {\n    return modifier;\n  }\n\n  const playerName = parseStringField(body.playerName, \"playerName\");\n  if (playerName instanceof Response) {\n    return playerName;\n  }\n\n  const label = parseStringField(body.label, \"label\");\n  if (label instanceof Response) {\n    return label;\n  }\n\n  const skill = parseStringField(body.skill, \"skill\");\n  if (skill instanceof Response) {\n    return skill;\n  }\n\n  const requestId = parseStringField(body.requestId, \"requestId\");\n  if (requestId instanceof Response) {\n    return requestId;\n  }\n\n  return {\n    playerId,\n    playerName,\n    modifier,\n    label,\n    skill,\n    requestId,\n  };\n}\n\nfunction parseContestSelection(body: unknown): ContestSelectionPayload | Response {\n  if (!isRecord(body)) {\n    return jsonResponse({ error: \"Invalid payload.\" }, 400);\n  }\n\n  const requestId = parseRequiredStringField(body.requestId, \"requestId\");\n  if (requestId instanceof Response) {\n    return requestId;\n  }\n\n  const gmId = parseRequiredStringField(body.gmId, \"gmId\");\n  if (gmId instanceof Response) {\n    return gmId;\n  }\n\n  const npcModifier = parseNumberField(body.npcModifier, \"npcModifier\");\n  if (npcModifier instanceof Response) {\n    return npcModifier;\n  }\n\n  const gmName = parseStringField(body.gmName, \"gmName\");\n  if (gmName instanceof Response) {\n    return gmName;\n  }\n\n  const npcName = parseStringField(body.npcName, \"npcName\");\n  if (npcName instanceof Response) {\n    return npcName;\n  }\n\n  const contestId = parseStringField(body.contestId, \"contestId\");\n  if (contestId instanceof Response) {\n    return contestId;\n  }\n\n  return {\n    requestId,\n    gmId,\n    gmName,\n    npcName,\n    npcModifier,\n    contestId,\n  };\n}\n\nfunction rollD100(): number {\n  const buffer = new Uint32Array(1);\n  crypto.getRandomValues(buffer);\n  return (buffer[0] % 100) + 1;\n}\n\nfunction mapRollRequestForSupabase(record: RollRequestRecord): Record<string, unknown> {\n  return {\n    id: record.id,\n    campaign_id: record.campaignId,\n    player_id: record.playerId,\n    player_name: record.playerName ?? null,\n    roll: record.roll,\n    modifier: record.modifier,\n    total: record.total,\n    label: record.label ?? null,\n    skill: record.skill ?? null,\n    status: record.status,\n    contest_id: record.contestId ?? null,\n    created_at: record.createdAt,\n  };\n}\n\nfunction mapContestForSupabase(record: ContestRecord): Record<string, unknown> {\n  return {\n    id: record.id,\n    campaign_id: record.campaignId,\n    roll_request_id: record.requestId,\n    gm_id: record.gmId,\n    gm_name: record.gmName ?? null,\n    npc_name: record.npcName ?? null,\n    npc_modifier: record.npcModifier,\n    npc_roll: record.npcRoll,\n    npc_total: record.npcTotal,\n    player_roll: record.playerRoll,\n    player_modifier: record.playerModifier,\n    player_total: record.playerTotal,\n    outcome: record.outcome,\n    created_at: record.createdAt,\n  };\n}\n\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const corsHeaders = getCorsHeaders(request);\n\n    // Handle CORS preflight requests\n    if (request.method === \"OPTIONS\") {\n      return new Response(null, {\n        status: 204,\n        headers: corsHeaders,\n      });\n    }\n\n    const url = new URL(request.url);\n    const match = url.pathname.match(/^\\/api\\/campaigns\\/([^/]+)\\/(connect|roll|contest)$/);\n    const combatMatch = url.pathname.match(\n      /^\\/api\\/campaigns\\/([^/]+)\\/combat\\/[^/]+$/,\n    );\n    if (!match && !combatMatch) {\n      return new Response(\n        JSON.stringify({ error: \"Not found\" }),\n        {\n          status: 404,\n          headers: {\n            \"content-type\": \"application/json\",\n            ...corsHeaders,\n          }\n        }\n      );\n    }\n\n    const campaignId = decodeURIComponent((match ?? combatMatch)![1]);\n    const id = env.CAMPAIGN_DO.idFromName(campaignId);\n    const stub = env.CAMPAIGN_DO.get(id);\n\n    return stub.fetch(request);\n  },\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/home/sloth/Character_Sheet_Project/functions/_worker.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/home/sloth/Character_Sheet_Project/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/home/sloth/Character_Sheet_Project/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/home/sloth/Character_Sheet_Project/functions/_worker.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/home/sloth/Character_Sheet_Project/.wrangler/tmp/bundle-Fh0bng/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/home/sloth/Character_Sheet_Project/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/home/sloth/Character_Sheet_Project/.wrangler/tmp/bundle-Fh0bng/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/home/sloth/Character_Sheet_Project/.wrangler/tmp/bundle-Fh0bng/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": ";;;;AAAA,IAAM,OAAO,oBAAI,IAAI;AAErB,SAAS,SAAS,SAAS,MAAM;AAChC,QAAM,MACL,mBAAmB,MAChB,UACA,IAAI;AAAA,KACH,OAAO,YAAY,WACjB,IAAI,QAAQ,SAAS,IAAI,IACzB,SACD;AAAA,EACH;AACH,MAAI,IAAI,QAAQ,IAAI,SAAS,SAAS,IAAI,aAAa,UAAU;AAChE,QAAI,CAAC,KAAK,IAAI,IAAI,SAAS,CAAC,GAAG;AAC9B,WAAK,IAAI,IAAI,SAAS,CAAC;AACvB,cAAQ;AAAA,QACP;AAAA,KACO,IAAI,SAAS,CAAC;AAAA;AAAA,MACtB;AAAA,IACD;AAAA,EACD;AACD;AAnBS;AAqBT,WAAW,QAAQ,IAAI,MAAM,WAAW,OAAO;AAAA,EAC9C,MAAM,QAAQ,SAAS,UAAU;AAChC,UAAM,CAAC,SAAS,IAAI,IAAI;AACxB,aAAS,SAAS,IAAI;AACtB,WAAO,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAAA,EAC/C;AACD,CAAC;;;ACND,SAAS,eAAe,SAA+B;AACrD,QAAM,SAAS,QAAQ,QAAQ,IAAI,QAAQ;AAE3C,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA;AAAA,EACF;AAEA,QAAM,YAAY,WAChB,eAAe,KAAK,aAAW,WAAW,WAAW,OAAO,WAAW,OAAO,CAAC,KAC/E,8DAA8D,KAAK,MAAM,KACzE,8BAA8B,KAAK,MAAM;AAG3C,MAAI,WAAW;AACb,WAAO;AAAA,MACL,+BAA+B;AAAA,MAC/B,gCAAgC;AAAA,MAChC,gCAAgC;AAAA,MAChC,0BAA0B;AAAA,MAC1B,oCAAoC;AAAA,IACtC;AAAA,EACF;AAEA,SAAO,CAAC;AACV;AAzBS;AAkcF,IAAM,wBAAN,MAA4B;AAAA,EAzdnC,OAydmC;AAAA;AAAA;AAAA,EACzB;AAAA,EACA;AAAA,EACA,WAAW,oBAAI,IAAuB;AAAA,EACtC,WAAW,oBAAI,IAA4B;AAAA,EAC3C,aAAgC;AAAA,EAChC,WAAW;AAAA,EACX;AAAA,EAER,YAAY,OAA2B,KAAU;AAC/C,SAAK,QAAQ;AACb,SAAK,MAAM;AACX,SAAK,QAAQ,KAAK,MAAM,sBAAsB,YAAY;AACxD,YAAM,iBAAiB,MAAM,KAAK,MAAM,QAAQ,IAAY,UAAU;AACtE,UAAI,OAAO,mBAAmB,UAAU;AACtC,aAAK,WAAW;AAAA,MAClB;AAGA,YAAM,mBAAmB,MAAM,KAAK,MAAM,QAAQ,IAAgB,YAAY;AAC9E,UAAI,kBAAkB;AACpB,aAAK,aAAa;AAAA,MACpB;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,MAAM,SAAqC;AAC/C,UAAM,KAAK;AAGX,QAAI,QAAQ,WAAW,WAAW;AAChC,aAAO,IAAI,SAAS,MAAM;AAAA,QACxB,QAAQ;AAAA,QACR,SAAS,eAAe,OAAO;AAAA,MACjC,CAAC;AAAA,IACH;AAEA,UAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,UAAM,QAAQ,IAAI,SAAS,MAAM,qDAAqD;AACtF,UAAM,cAAc,IAAI,SAAS;AAAA,MAC/B;AAAA,IACF;AACA,QAAI,CAAC,SAAS,CAAC,aAAa;AAC1B,aAAO,aAAa,EAAE,OAAO,YAAY,GAAG,GAAG;AAAA,IACjD;AAEA,UAAM,aAAa,oBAAoB,SAAS,aAAc,CAAC,CAAC;AAChE,UAAM,UAAU,SAAS,aAAc,CAAC;AAGxC,QAAI,WAAW,WAAW;AACxB,aAAO,KAAK,cAAc,SAAS,UAAU;AAAA,IAC/C;AAGA,QAAI,QAAQ,WAAW,QAAQ;AAC7B,aAAO,aAAa,EAAE,OAAO,qBAAqB,GAAG,KAAK,EAAE,OAAO,OAAO,GAAG,OAAO;AAAA,IACtF;AAEA,UAAM,OAAO,MAAM,aAAa,OAAO;AACvC,QAAI,gBAAgB,UAAU;AAC5B,aAAO;AAAA,IACT;AAEA,QAAI,WAAW,QAAQ;AACrB,aAAO,KAAK,kBAAkB,YAAY,MAAM,OAAO;AAAA,IACzD;AAEA,QAAI,WAAW,WAAW;AACxB,aAAO,KAAK,qBAAqB,YAAY,MAAM,OAAO;AAAA,IAC5D;AAEA,QAAI,aAAa;AACf,aAAO,KAAK,mBAAmB,YAAY,QAAQ,MAAM,OAAO;AAAA,IAClE;AAEA,WAAO,aAAa,EAAE,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAC9D;AAAA,EAEA,MAAc,cAAc,SAAkB,YAAuC;AACnF,QAAI,QAAQ,QAAQ,IAAI,SAAS,MAAM,aAAa;AAClD,aAAO,aAAa,EAAE,OAAO,6BAA6B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC/E;AAEA,UAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,UAAM,eAAe,OAAO,WAAW;AACvC,UAAM,SAAS,IAAI,aAAa,IAAI,MAAM,KAAK;AAE/C,UAAM,OAAO,IAAI,cAAc;AAC/B,UAAM,SAAS,KAAK,CAAC;AACrB,UAAM,SAAS,KAAK,CAAC;AACrB,WAAO,OAAO;AAEd,SAAK,SAAS,IAAI,cAAc,MAAM;AACtC,SAAK,SAAS,IAAI,cAAc;AAAA,MAC9B;AAAA,MACA,cAAa,oBAAI,KAAK,GAAE,YAAY;AAAA,IACtC,CAAC;AAED,WAAO,iBAAiB,WAAW,CAAC,UAAU;AAC5C,WAAK,KAAK,oBAAoB,cAAc,YAAY,MAAM,IAAI;AAAA,IACpE,CAAC;AAED,WAAO,iBAAiB,SAAS,MAAM;AACrC,WAAK,iBAAiB,cAAc,UAAU;AAAA,IAChD,CAAC;AAED,WAAO,iBAAiB,SAAS,MAAM;AACrC,WAAK,iBAAiB,cAAc,UAAU;AAAA,IAChD,CAAC;AAED,UAAM,iBAAgC;AAAA,MACpC,MAAM;AAAA,MACN;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,SAAS;AAAA,QACP;AAAA,QACA,UAAU,KAAK,gBAAgB;AAAA,QAC/B,UAAU,KAAK;AAAA,MACjB;AAAA,IACF;AACA,WAAO,KAAK,KAAK,UAAU,cAAc,CAAC;AAG1C,QAAI,KAAK,YAAY;AACnB,YAAM,iBAAiB;AAAA,QACrB,MAAM;AAAA,QACN;AAAA,QACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,QAClC,SAAS;AAAA,UACP,YAAY,KAAK;AAAA,QACnB;AAAA,MACF;AACA,aAAO,KAAK,KAAK,UAAU,cAAc,CAAC;AAAA,IAC5C;AAEA,SAAK,UAAU;AAAA,MACb,MAAM;AAAA,MACN;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,SAAS;AAAA,QACP,QAAQ;AAAA,QACR,GAAG,KAAK,kBAAkB,YAAY;AAAA,QACtC,OAAO,KAAK,SAAS;AAAA,MACvB;AAAA,IACF,CAAC;AAED,WAAO,IAAI,SAAS,MAAM;AAAA,MACxB,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,SAAS,eAAe,OAAO;AAAA,IACjC,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,oBAAoB,cAAsB,YAAoB,MAAe;AACzF,QAAI,OAAO,SAAS,UAAU;AAC5B;AAAA,IACF;AAEA,QAAI;AACJ,QAAI;AACF,gBAAU,KAAK,MAAM,IAAI;AAAA,IAC3B,QAAQ;AACN;AAAA,IACF;AAGA,QAAI,SAAS,SAAS,cAAc,QAAQ,QAAQ;AAClD,YAAM,UAAU,KAAK,SAAS,IAAI,YAAY;AAC9C,UAAI,CAAC,WAAW,QAAQ,WAAW,QAAQ,QAAQ;AACjD;AAAA,MACF;AAEA,WAAK,SAAS,IAAI,cAAc,EAAE,GAAG,SAAS,QAAQ,QAAQ,OAAO,CAAC;AACtE,WAAK,UAAU;AAAA,QACb,MAAM;AAAA,QACN;AAAA,QACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,QAClC,SAAS;AAAA,UACP,QAAQ;AAAA,UACR,GAAG,KAAK,kBAAkB,YAAY;AAAA,UACtC,OAAO,KAAK,SAAS;AAAA,QACvB;AAAA,MACF,CAAC;AAAA,IACH;AAGA,QAAI,SAAS,SAAS,gBAAgB,QAAQ,QAAQ;AACpD,WAAK,gBAAgB,YAAY,QAAQ,QAAQ,QAAQ,WAAW;AAAA,IACtE;AAEA,QAAI,SAAS,SAAS,iBAAiB,QAAQ,QAAQ;AACrD,WAAK,iBAAiB,YAAY,QAAQ,MAAM;AAAA,IAClD;AAEA,QAAI,SAAS,SAAS,wBAAwB,QAAQ,QAAQ;AAC5D,WAAK,uBAAuB,YAAY,QAAQ,QAAQ,QAAQ,WAAW,OAAO,QAAQ,WAAW;AAAA,IACvG;AAEA,QAAI,SAAS,SAAS,iBAAiB;AACrC,YAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,YAAM,SAAS,KAAK,SAAS,IAAI,YAAY;AAC7C,UAAI,CAAC,eAAe,CAAC,OAAQ;AAE7B,aAAO,KAAK,KAAK,UAAU;AAAA,QACzB,MAAM;AAAA,QACN;AAAA,QACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,QAClC,SAAS,EAAE,OAAO,YAAY;AAAA,MAChC,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AAAA,EAEQ,iBAAiB,cAAsB,YAAoB;AACjE,QAAI,CAAC,KAAK,SAAS,IAAI,YAAY,GAAG;AACpC;AAAA,IACF;AAEA,SAAK,SAAS,OAAO,YAAY;AACjC,UAAM,gBAAgB,KAAK,kBAAkB,YAAY;AACzD,SAAK,SAAS,OAAO,YAAY;AAEjC,SAAK,UAAU;AAAA,MACb,MAAM;AAAA,MACN;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,SAAS;AAAA,QACP,QAAQ;AAAA,QACR,GAAG;AAAA,QACH,OAAO,KAAK,SAAS;AAAA,MACvB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAMQ,gBAAgB,YAAoB;AAC1C,QAAI,CAAC,KAAK,YAAY;AACpB,WAAK,aAAa;AAAA,QAChB;AAAA,QACA,SAAS,CAAC;AAAA,QACV,YAAY;AAAA,QACZ,YAAY;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAc,iBAAiB;AAC7B,QAAI,KAAK,YAAY;AACnB,YAAM,KAAK,MAAM,QAAQ,IAAI,cAAc,KAAK,UAAU;AAAA,IAC5D;AAAA,EACF;AAAA,EAEQ,gBAAgB,YAAoB,QAAgB,aAAsB;AAChF,SAAK,gBAAgB,UAAU;AAE/B,QAAI,CAAC,KAAK,WAAY;AAEtB,UAAM,YAAW,oBAAI,KAAK,GAAE,YAAY;AACxC,UAAM,WAAW,KAAK,WAAW,QAAQ,MAAM,GAAG,WAAW;AAE7D,SAAK,WAAW,QAAQ,MAAM,IAAI;AAAA,MAChC;AAAA,MACA;AAAA,MACA,SAAS;AAAA;AAAA,MACT;AAAA,IACF;AAEA,SAAK,WAAW,aAAa,OAAO,KAAK,KAAK,WAAW,OAAO,EAAE;AAClE,SAAK,WAAW,aAAa,OAAO,OAAO,KAAK,WAAW,OAAO,EAAE,OAAO,OAAK,EAAE,OAAO,EAAE;AAG3F,SAAK,eAAe;AAGpB,SAAK,UAAU;AAAA,MACb,MAAM;AAAA,MACN;AAAA,MACA,WAAW;AAAA,MACX,SAAS;AAAA,QACP;AAAA,QACA;AAAA,QACA;AAAA,QACA,YAAY,KAAK;AAAA,MACnB;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,iBAAiB,YAAoB,QAAgB;AAC3D,QAAI,CAAC,KAAK,cAAc,CAAC,KAAK,WAAW,QAAQ,MAAM,EAAG;AAE1D,WAAO,KAAK,WAAW,QAAQ,MAAM;AAErC,SAAK,WAAW,aAAa,OAAO,KAAK,KAAK,WAAW,OAAO,EAAE;AAClE,SAAK,WAAW,aAAa,OAAO,OAAO,KAAK,WAAW,OAAO,EAAE,OAAO,OAAK,EAAE,OAAO,EAAE;AAE3F,UAAM,UAAS,oBAAI,KAAK,GAAE,YAAY;AAGtC,SAAK,eAAe;AAGpB,SAAK,UAAU;AAAA,MACb,MAAM;AAAA,MACN;AAAA,MACA,WAAW;AAAA,MACX,SAAS;AAAA,QACP;AAAA,QACA;AAAA,QACA,YAAY,KAAK;AAAA,MACnB;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,uBAAuB,YAAoB,QAAgB,SAAkB,aAAsB;AACzG,SAAK,gBAAgB,UAAU;AAE/B,QAAI,CAAC,KAAK,WAAY;AAGtB,QAAI,CAAC,KAAK,WAAW,QAAQ,MAAM,GAAG;AACpC,WAAK,WAAW,QAAQ,MAAM,IAAI;AAAA,QAChC;AAAA,QACA;AAAA,QACA,SAAS;AAAA,QACT,WAAU,oBAAI,KAAK,GAAE,YAAY;AAAA,MACnC;AAAA,IACF;AAGA,SAAK,WAAW,QAAQ,MAAM,EAAE,UAAU;AAC1C,QAAI,aAAa;AACf,WAAK,WAAW,QAAQ,MAAM,EAAE,cAAc;AAAA,IAChD;AAEA,SAAK,WAAW,aAAa,OAAO,OAAO,KAAK,WAAW,OAAO,EAAE,OAAO,OAAK,EAAE,OAAO,EAAE;AAG3F,SAAK,eAAe;AAGpB,SAAK,UAAU;AAAA,MACb,MAAM;AAAA,MACN;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,SAAS;AAAA,QACP;AAAA,QACA;AAAA,QACA;AAAA,QACA,YAAY,KAAK;AAAA,MACnB;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,eAAe;AAC3B,UAAM,OAAO,KAAK,WAAW;AAC7B,SAAK,WAAW;AAChB,UAAM,KAAK,MAAM,QAAQ,IAAI,YAAY,IAAI;AAC7C,WAAO;AAAA,EACT;AAAA,EAEQ,eAAe,YAAoB;AACzC,WAAO,gBAAgB,UAAU;AAAA,EACnC;AAAA,EAEA,MAAc,gBAAgB,YAAiD;AAC7E,WAAO,KAAK,MAAM,sBAAsB,YAAY;AAClD,aAAO,KAAK,MAAM,QAAQ,IAAiB,KAAK,eAAe,UAAU,CAAC;AAAA,IAC5E,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,gBAAgB,YAAoB,aAA2C;AAC3F,WAAO,KAAK,MAAM,sBAAsB,YAAY;AAClD,YAAM,OAAO,KAAK,WAAW;AAC7B,WAAK,WAAW;AAChB,YAAM,KAAK,MAAM,QAAQ,IAAI;AAAA,QAC3B,CAAC,KAAK,eAAe,UAAU,CAAC,GAAG;AAAA,QACnC,UAAU;AAAA,MACZ,CAAC;AACD,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,qBACZ,YACA,MACA,SACA;AACA,UAAM,WAAW,MAAM,KAAK,wBAAwB;AACpD,SAAK,UAAU;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,0BAA2C;AACvD,WAAO,KAAK,MAAM,sBAAsB,YAAY;AAClD,YAAM,OAAO,KAAK,WAAW;AAC7B,WAAK,WAAW;AAChB,YAAM,KAAK,MAAM,QAAQ,IAAI,YAAY,IAAI;AAC7C,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,kBAAkB,YAAoB,MAAe,SAAqC;AACtG,UAAM,SAAS,iBAAiB,IAAI;AACpC,QAAI,kBAAkB,UAAU;AAC9B,aAAO;AAAA,IACT;AAEA,UAAM,YAAY,OAAO,aAAa,OAAO,WAAW;AACxD,UAAM,OAAO,SAAS;AACtB,UAAM,WAAW,OAAO,YAAY;AACpC,UAAM,QAAQ,OAAO;AACrB,UAAM,aAAY,oBAAI,KAAK,GAAE,YAAY;AAEzC,UAAM,SAA4B;AAAA,MAChC,IAAI;AAAA,MACJ;AAAA,MACA,UAAU,OAAO;AAAA,MACjB,YAAY,OAAO;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO,OAAO;AAAA,MACd,OAAO,OAAO;AAAA,MACd;AAAA,MACA,QAAQ;AAAA,IACV;AAEA,UAAM,mBAAmB,MAAM,KAAK;AAAA,MAClC;AAAA,MACA,0BAA0B,MAAM;AAAA,MAChC,EAAE,QAAQ,KAAK;AAAA,IACjB;AACA,QAAI,kBAAkB;AACpB,aAAO;AAAA,IACT;AAEA,UAAM,KAAK,MAAM,QAAQ,IAAI,KAAK,eAAe,SAAS,GAAG,MAAM;AAEnE,UAAM,WAAW,MAAM,KAAK,aAAa;AACzC,UAAM,QAAuB;AAAA,MAC3B,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,WAAW;AAAA,MACX,SAAS,EAAE,SAAS,OAAO;AAAA,IAC7B;AAEA,SAAK,UAAU,KAAK;AAEpB,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,SAAS,OAAO,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAC/E;AAAA,EAEA,MAAc,qBAAqB,YAAoB,MAAe,SAAqC;AACzG,UAAM,SAAS,sBAAsB,IAAI;AACzC,QAAI,kBAAkB,UAAU;AAC9B,aAAO;AAAA,IACT;AAEA,UAAM,aAAa,KAAK,eAAe,OAAO,SAAS;AACvD,UAAM,cAAc,MAAM,KAAK,MAAM,QAAQ,IAAuB,UAAU;AAC9E,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,YAAY,OAAO,aAAa,OAAO,WAAW;AACxD,UAAM,UAAU,SAAS;AACzB,UAAM,cAAc,OAAO,eAAe;AAC1C,UAAM,WAAW,UAAU;AAC3B,UAAM,aAAY,oBAAI,KAAK,GAAE,YAAY;AACzC,UAAM,UACJ,YAAY,UAAU,WAAW,QAAQ,YAAY,QAAQ,WAAW,WAAW;AAErF,UAAM,UAAyB;AAAA,MAC7B,IAAI;AAAA,MACJ;AAAA,MACA,WAAW,YAAY;AAAA,MACvB,MAAM,OAAO;AAAA,MACb,QAAQ,OAAO;AAAA,MACf,SAAS,OAAO;AAAA,MAChB;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAY,YAAY;AAAA,MACxB,gBAAgB,YAAY;AAAA,MAC5B,aAAa,YAAY;AAAA,MACzB;AAAA,MACA;AAAA,IACF;AAEA,UAAM,iBAAoC;AAAA,MACxC,GAAG;AAAA,MACH,QAAQ;AAAA,MACR;AAAA,IACF;AAEA,UAAM,mBAAmB,MAAM,KAAK;AAAA,MAClC;AAAA,MACA,sBAAsB,OAAO;AAAA,MAC7B,EAAE,QAAQ,KAAK;AAAA,IACjB;AACA,QAAI,kBAAkB;AACpB,aAAO;AAAA,IACT;AAEA,UAAM,qBAAqB,MAAM,KAAK;AAAA,MACpC;AAAA,MACA,0BAA0B,cAAc;AAAA,MACxC,EAAE,QAAQ,KAAK;AAAA,IACjB;AACA,QAAI,oBAAoB;AACtB,aAAO;AAAA,IACT;AAEA,UAAM,KAAK,MAAM,QAAQ,IAAI,YAAY,cAAc;AACvD,UAAM,KAAK,MAAM,QAAQ,IAAI,KAAK,eAAe,SAAS,GAAG,OAAO;AAEpE,UAAM,WAAW,MAAM,KAAK,aAAa;AACzC,UAAM,QAAuB;AAAA,MAC3B,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,WAAW;AAAA,MACX,SAAS,EAAE,SAAS,gBAAgB,QAAQ;AAAA,IAC9C;AAEA,SAAK,UAAU,KAAK;AAEpB,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,QAAQ,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EACvE;AAAA,EAEA,MAAc,mBACZ,YACA,QACA,MACA,SACmB;AACnB,YAAQ,QAAQ;AAAA;AAAA;AAAA;AAAA,MAId,KAAK;AACH,eAAO,KAAK,yBAAyB,YAAY,OAAO;AAAA,MAC1D,KAAK;AACH,eAAO,KAAK,yBAAyB,YAAY,MAAM,OAAO;AAAA,MAChE,KAAK;AACH,eAAO,KAAK,2BAA2B,YAAY,MAAM,OAAO;AAAA,MAClE,KAAK;AACH,eAAO,KAAK,oBAAoB,YAAY,MAAM,OAAO;AAAA,MAC3D,KAAK;AACH,eAAO,KAAK,sBAAsB,YAAY,MAAM,OAAO;AAAA,MAC7D,KAAK;AACH,eAAO,KAAK,uBAAuB,YAAY,MAAM,OAAO;AAAA,MAC9D,KAAK;AACH,eAAO,KAAK,2BAA2B,YAAY,MAAM,OAAO;AAAA,MAClE,KAAK;AACH,eAAO,KAAK,iBAAiB,YAAY,MAAM,OAAO;AAAA,MACxD,KAAK;AACH,eAAO,KAAK,gBAAgB,YAAY,MAAM,OAAO;AAAA,MACvD,KAAK;AACH,eAAO,KAAK,2BAA2B,YAAY,MAAM,OAAO;AAAA,MAClE,KAAK;AACH,eAAO,KAAK,0BAA0B,YAAY,MAAM,OAAO;AAAA,MACjE,KAAK;AACH,eAAO,KAAK,wBAAwB,YAAY,MAAM,OAAO;AAAA,MAC/D,KAAK;AACH,eAAO,KAAK,uBAAuB,YAAY,MAAM,OAAO;AAAA,MAC9D,KAAK;AACH,eAAO,KAAK,mBAAmB,YAAY,MAAM,OAAO;AAAA;AAAA;AAAA;AAAA,MAK1D,KAAK;AACH,eAAO,KAAK,kBAAkB,YAAY,OAAO;AAAA,MACnD,KAAK;AACH,eAAO,KAAK,kBAAkB,YAAY,MAAM,OAAO;AAAA,MACzD,KAAK;AAAA,MACL,KAAK;AACH,eAAO,KAAK,oBAAoB,YAAY,MAAM,OAAO;AAAA,MAC3D,KAAK;AACH,eAAO,KAAK,mBAAmB,YAAY,MAAM,OAAO;AAAA,MAC1D,KAAK;AACH,eAAO,KAAK,kBAAkB,YAAY,MAAM,OAAO;AAAA,MACzD,KAAK;AACH,eAAO,KAAK,qBAAqB,YAAY,MAAM,OAAO;AAAA,MAC5D;AACE,eAAO,aAAa,EAAE,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAChE;AAAA,EACF;AAAA,EAEA,MAAc,kBAAkB,YAAoB,SAAqC;AACvF,UAAM,cAAc,MAAM,KAAK,gBAAgB,UAAU;AACzD,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,KAAK,UAAU,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EACjG;AAAA,EAEA,MAAc,mBAAmB,YAAoB,MAAe,SAAqC;AACvG,UAAM,SAAS,kBAAkB,IAAI;AACrC,QAAI,kBAAkB,UAAU;AAC9B,aAAO;AAAA,IACT;AAEA,UAAM,cAAc,MAAM,KAAK,gBAAgB,UAAU;AACzD,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,WAAW,OAAO,eAAe,YAAY;AACnD,QAAI,CAAC,UAAU;AACb,aAAO,aAAa,EAAE,OAAO,iDAAiD,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACnG;AAEA,UAAM,mBAAmB,YAAY,iBAAiB,QAAQ,KAAK;AACnE,QAAI,kBAAkB;AACpB,kBAAY,iBAAiB,QAAQ,IAAI;AAAA,IAC3C;AAEA,UAAM,cAAc,0BAA0B,mBAAmB;AAAA,MAC/D,aAAa;AAAA,MACb;AAAA,IACF,CAAC;AACD,gBAAY,SAAS,KAAK,WAAW;AAErC,UAAM,WAAW,MAAM,KAAK,gBAAgB,YAAY,WAAW;AACnE,SAAK,UAAU;AAAA,MACb,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,WAAW,YAAY;AAAA,MACvB,SAAS,EAAE,OAAO,aAAa,aAAa,UAAU,iBAAiB;AAAA,IACzE,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAClF;AAAA,EAEA,MAAc,kBAAkB,YAAoB,MAAe,SAAqC;AACtG,UAAM,SAAS,iBAAiB,IAAI;AACpC,QAAI,kBAAkB,UAAU;AAC9B,aAAO;AAAA,IACT;AAEA,QAAI,aAAa,OAAO;AACxB,QAAI,WAAW,WAAW,GAAG;AAC3B,YAAM,SAAS,MAAM,KAAK,2BAA2B,UAAU;AAC/D,UAAI,kBAAkB,UAAU;AAC9B,eAAO;AAAA,MACT;AACA,mBAAa;AAAA,IACf;AAEA,QAAI,WAAW,WAAW,GAAG;AAC3B,aAAO,aAAa,EAAE,OAAO,2CAA2C,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC7F;AAEA,UAAM,cAAc,IAAI,IAAI,OAAO,eAAe,CAAC,CAAC;AACpD,UAAM,mBAAmB,oBAAI,IAAoB;AACjD,UAAM,cAAc,oBAAI,IAAoB;AAE5C,eAAW,QAAQ,CAAC,cAAc;AAChC,YAAM,SACH,UAAU,cAAc,MACxB,UAAU,kBAAkB,MAC5B,UAAU,mBAAmB;AAChC,uBAAiB,IAAI,UAAU,IAAI,KAAK;AACxC,UAAI,OAAO,iBAAiB;AAC1B,cAAM,WAAW,UAAU,WAAW,UAAU;AAChD,cAAM,UAAU,YAAY,IAAI,QAAQ;AACxC,YAAI,WAAW,QAAQ,QAAQ,SAAS;AACtC,sBAAY,IAAI,UAAU,KAAK;AAAA,QACjC;AAAA,MACF;AAAA,IACF,CAAC;AAED,UAAM,kBAAkB,CAAC,GAAG,UAAU,EACnC,KAAK,CAAC,MAAM,UAAU;AACrB,YAAM,YAAY,OAAO,kBACrB,YAAY,IAAI,KAAK,WAAW,KAAK,EAAE,KAAK,IAC5C,iBAAiB,IAAI,KAAK,EAAE,KAAK;AACrC,YAAM,aAAa,OAAO,kBACtB,YAAY,IAAI,MAAM,WAAW,MAAM,EAAE,KAAK,IAC9C,iBAAiB,IAAI,MAAM,EAAE,KAAK;AACtC,UAAI,cAAc,YAAY;AAC5B,eAAO,aAAa;AAAA,MACtB;AACA,YAAM,UAAU,iBAAiB,IAAI,KAAK,EAAE,KAAK;AACjD,YAAM,WAAW,iBAAiB,IAAI,MAAM,EAAE,KAAK;AACnD,UAAI,YAAY,UAAU;AACxB,eAAO,WAAW;AAAA,MACpB;AACA,aAAO,KAAK,GAAG,cAAc,MAAM,EAAE;AAAA,IACvC,CAAC,EACA,IAAI,CAAC,cAAc,UAAU,EAAE;AAElC,UAAM,OAAM,oBAAI,KAAK,GAAE,YAAY;AACnC,UAAM,cAA2B;AAAA,MAC/B,OAAO;AAAA,MACP,WAAW;AAAA,MACX;AAAA,MACA,mBAAmB,gBAAgB,CAAC,KAAK;AAAA,MACzC,kBAAkB,CAAC;AAAA,MACnB,kBAAkB,CAAC;AAAA,MACnB,qBAAqB,CAAC;AAAA,MACtB,YAAY,CAAC;AAAA,MACb,mBAAmB,CAAC;AAAA,MACpB,YAAY,CAAC;AAAA,MACb,mBAAmB,CAAC;AAAA,MACpB,UAAU,CAAC;AAAA,IACb;AAEA,eAAW,aAAa,YAAY;AAClC,YAAM,KAAK,UAAU;AACrB,YAAM,eAAe,UAAU,gBAAgB;AAC/C,kBAAY,iBAAiB,EAAE,IAAI;AACnC,kBAAY,oBAAoB,EAAE,IAAI;AACtC,kBAAY,WAAW,EAAE,IAAI,UAAU,UAAU;AACjD,kBAAY,kBAAkB,EAAE,IAAI,UAAU,iBAAiB,CAAC;AAChE,kBAAY,WAAW,EAAE,IAAI,UAAU,UAAU;AACjD,kBAAY,kBAAkB,EAAE,IAAI;AACpC,UAAI,UAAU,YAAY,YAAY,IAAI,EAAE,GAAG;AAC7C,oBAAY,iBAAiB,EAAE,IAAI;AAAA,MACrC;AAAA,IACF;AAEA,UAAM,eAAe,0BAA0B,kBAAkB;AAAA,MAC/D;AAAA,MACA,iBAAiB,OAAO;AAAA,IAC1B,CAAC;AACD,gBAAY,SAAS,KAAK,YAAY;AAEtC,QAAI,YAAY,mBAAmB;AACjC,kBAAY,SAAS;AAAA,QACnB,0BAA0B,gBAAgB;AAAA,UACxC,aAAa,YAAY;AAAA,UACzB,OAAO,YAAY;AAAA,UACnB,WAAW,YAAY;AAAA,QACzB,CAAC;AAAA,MACH;AAAA,IACF;AAEA,UAAM,WAAW,MAAM,KAAK,gBAAgB,YAAY,WAAW;AACnE,SAAK,UAAU;AAAA,MACb,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,WAAW;AAAA,MACX,SAAS,EAAE,OAAO,YAAY;AAAA,IAChC,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAClF;AAAA,EAEA,MAAc,oBAAoB,YAAoB,MAAe,SAAqC;AACxG,UAAM,SAAS,mBAAmB,IAAI;AACtC,QAAI,kBAAkB,UAAU;AAC9B,aAAO;AAAA,IACT;AAEA,UAAM,cAAc,MAAM,KAAK,gBAAgB,UAAU;AACzD,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,OAAM,oBAAI,KAAK,GAAE,YAAY;AACnC,UAAM,sBAAsB,YAAY;AAExC,QAAI,OAAO,mBAAmB;AAC5B,iBAAW,CAAC,aAAa,aAAa,KAAK,OAAO,QAAQ,OAAO,iBAAiB,GAAG;AACnF,oBAAY,kBAAkB,WAAW,IAAI;AAAA,MAC/C;AAAA,IACF;AAEA,QAAI,qBAAqB;AACvB,kBAAY,SAAS;AAAA,QACnB,0BAA0B,cAAc;AAAA,UACtC,aAAa;AAAA,UACb,OAAO,YAAY;AAAA,UACnB,WAAW,YAAY;AAAA,QACzB,CAAC;AAAA,MACH;AAAA,IACF;AAEA,gBAAY,SAAS;AAAA,MACnB,0BAA0B,eAAe;AAAA,QACvC,aAAa;AAAA,QACb,sBAAsB,OAAO,qBAAqB;AAAA,MACpD,CAAC;AAAA,IACH;AAEA,UAAM,mBAAmB;AAAA,MACvB,uBAAuB,QACrB,YAAY,UAAU,KACtB,YAAY,iBAAiB,mBAAmB;AAAA,IACpD;AACA,QAAI,uBAAuB,kBAAkB;AAC3C,kBAAY,iBAAiB,mBAAmB,IAAI;AACpD,kBAAY,SAAS;AAAA,QACnB,0BAA0B,kBAAkB;AAAA,UAC1C,mBAAmB,CAAC,mBAAmB;AAAA,QACzC,CAAC;AAAA,MACH;AAAA,IACF;AAEA,UAAM,QAAQ,YAAY;AAC1B,QAAI,YAAY,YAAY,YAAY;AACxC,QAAI,YAAY,YAAY;AAC5B,QAAI,MAAM,WAAW,GAAG;AACtB,kBAAY,YAAY;AACxB,kBAAY,oBAAoB;AAAA,IAClC,OAAO;AACL,UAAI,aAAa,MAAM,QAAQ;AAC7B,oBAAY;AACZ,qBAAa;AAAA,MACf;AACA,kBAAY,YAAY;AACxB,kBAAY,QAAQ;AACpB,kBAAY,oBAAoB,MAAM,SAAS,KAAK;AAAA,IACtD;AAEA,QAAI,YAAY,mBAAmB;AACjC,YAAM,WAAW,YAAY;AAC7B,YAAM,kBAAkB,YAAY,oBAAoB,QAAQ;AAChE,UAAI,OAAO,oBAAoB,UAAU;AACvC,oBAAY,iBAAiB,QAAQ,IAAI;AAAA,MAC3C;AACA,kBAAY,SAAS;AAAA,QACnB,0BAA0B,gBAAgB;AAAA,UACxC,aAAa;AAAA,UACb,OAAO,YAAY;AAAA,UACnB,WAAW,YAAY;AAAA,QACzB,CAAC;AAAA,MACH;AAAA,IACF;AAEA,UAAM,WAAW,MAAM,KAAK,gBAAgB,YAAY,WAAW;AACnE,SAAK,UAAU;AAAA,MACb,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,WAAW;AAAA,MACX,SAAS;AAAA,QACP,OAAO;AAAA,QACP;AAAA,QACA,eAAe;AAAA,MACjB;AAAA,IACF,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAClF;AAAA,EAEA,MAAc,kBAAkB,YAAoB,MAAe,SAAqC;AACtG,UAAM,SAAS,iBAAiB,IAAI;AACpC,QAAI,kBAAkB,UAAU;AAC9B,aAAO;AAAA,IACT;AAEA,QAAI,OAAO,kBAAkB,GAAG;AAC9B,aAAO,aAAa,EAAE,OAAO,2CAA2C,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC7F;AAEA,UAAM,cAAc,MAAM,KAAK,gBAAgB,UAAU;AACzD,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,YAAY,YAAY,iBAAiB,OAAO,WAAW,KAAK;AACtE,UAAM,SAAS,YAAY,OAAO;AAClC,QAAI,SAAS,GAAG;AACd,aAAO,aAAa,EAAE,OAAO,8BAA8B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAChF;AAEA,UAAM,gBAAgB,YAAY,WAAW,OAAO,WAAW,KAAK;AACpE,UAAM,aAAa,gBAAgB,OAAO;AAC1C,QAAI,aAAa,GAAG;AAClB,aAAO,aAAa,EAAE,OAAO,uBAAuB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACzE;AAEA,gBAAY,iBAAiB,OAAO,WAAW,IAAI;AACnD,gBAAY,WAAW,OAAO,WAAW,IAAI;AAE7C,UAAM,cAAc,0BAA0B,gBAAgB;AAAA,MAC5D,aAAa,OAAO;AAAA,MACpB,iBAAiB,OAAO;AAAA,MACxB,YAAY,OAAO;AAAA,MACnB,YAAY,OAAO;AAAA,MACnB,UAAU,OAAO;AAAA,MACjB,aAAa,OAAO,eAAe;AAAA,MACnC,UAAU,OAAO,YAAY;AAAA,IAC/B,CAAC;AACD,gBAAY,SAAS,KAAK,WAAW;AAErC,UAAM,WAAW,MAAM,KAAK,gBAAgB,YAAY,WAAW;AACnE,SAAK,UAAU;AAAA,MACb,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,WAAW,YAAY;AAAA,MACvB,SAAS,EAAE,OAAO,aAAa,QAAQ,YAAY,QAAQ;AAAA,IAC7D,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAClF;AAAA,EAEA,MAAc,qBAAqB,YAAoB,MAAe,SAAqC;AACzG,UAAM,SAAS,oBAAoB,IAAI;AACvC,QAAI,kBAAkB,UAAU;AAC9B,aAAO;AAAA,IACT;AAEA,QAAI,OAAO,kBAAkB,GAAG;AAC9B,aAAO,aAAa,EAAE,OAAO,8BAA8B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAChF;AAEA,UAAM,cAAc,MAAM,KAAK,gBAAgB,UAAU;AACzD,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,YAAY,YAAY,iBAAiB,OAAO,WAAW,KAAK;AACtE,UAAM,SAAS,YAAY,OAAO;AAClC,QAAI,SAAS,GAAG;AACd,aAAO,aAAa,EAAE,OAAO,8BAA8B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAChF;AAEA,gBAAY,iBAAiB,OAAO,WAAW,IAAI;AACnD,gBAAY,kBAAkB,OAAO,WAAW,KAC7C,YAAY,kBAAkB,OAAO,WAAW,KAAK,KAAK;AAE7D,UAAM,gBAAgB,0BAA0B,kBAAkB;AAAA,MAChE,aAAa,OAAO;AAAA,MACpB,iBAAiB,OAAO;AAAA,MACxB,cAAc,OAAO;AAAA,MACrB,UAAU,OAAO,YAAY;AAAA,IAC/B,CAAC;AACD,gBAAY,SAAS,KAAK,aAAa;AAEvC,UAAM,WAAW,MAAM,KAAK,gBAAgB,YAAY,WAAW;AACnE,SAAK,UAAU;AAAA,MACb,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,WAAW,cAAc;AAAA,MACzB,SAAS,EAAE,OAAO,aAAa,UAAU,cAAc,QAAQ;AAAA,IACjE,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAClF;AAAA;AAAA;AAAA;AAAA,EAMQ,mBAAmB,YAA4B;AACrD,WAAO,qBAAqB,UAAU;AAAA,EACxC;AAAA,EAEA,MAAc,oBAAoB,YAA8D;AAC9F,WAAO,KAAK,MAAM,sBAAsB,YAAY;AAClD,aAAO,KAAK,MAAM,QAAQ,IAA8B,KAAK,mBAAmB,UAAU,CAAC;AAAA,IAC7F,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,oBACZ,YACA,aACiB;AACjB,WAAO,KAAK,MAAM,sBAAsB,YAAY;AAClD,YAAM,OAAO,KAAK,WAAW;AAC7B,WAAK,WAAW;AAChB,kBAAY,UAAU;AACtB,kBAAY,iBAAgB,oBAAI,KAAK,GAAE,YAAY;AACnD,YAAM,KAAK,MAAM,QAAQ,IAAI;AAAA,QAC3B,CAAC,KAAK,mBAAmB,UAAU,CAAC,GAAG;AAAA,QACvC,UAAU;AAAA,MACZ,CAAC;AACD,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EAEQ,mBACN,MACA,YACA,UACA,SACM;AACN,SAAK,UAAU;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,mBACN,MACA,gBACA,gBACA,MACgB;AAChB,WAAO;AAAA,MACL,IAAI,OAAO,WAAW;AAAA,MACtB,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGQ,eACN,OACA,UACA,UACA,QACA,YACuC;AACvC,QAAI,MAAM,UAAU,eAAe;AACjC,aAAO,EAAE,SAAS,OAAO,QAAQ,2BAA2B;AAAA,IAC9D;AAEA,QAAI,MAAM,mBAAmB,UAAU;AACrC,aAAO,EAAE,SAAS,OAAO,QAAQ,gBAAgB;AAAA,IACnD;AAEA,UAAM,SAAS,MAAM,SAAS,QAAQ;AACtC,QAAI,CAAC,QAAQ;AACX,aAAO,EAAE,SAAS,OAAO,QAAQ,mBAAmB;AAAA,IACtD;AAEA,QAAI,CAAC,OAAO,OAAO;AACjB,aAAO,EAAE,SAAS,OAAO,QAAQ,sBAAsB;AAAA,IACzD;AAGA,UAAM,OAAO,aAAa,QAAQ,SAAS,WAAW,KAAK;AAC3D,QAAI,CAAC,QAAQ,OAAO,eAAe,YAAY,OAAO,eAAe,UAAU,QAAQ,IAAI;AACzF,aAAO,EAAE,SAAS,OAAO,QAAQ,iCAAiC;AAAA,IACpE;AAEA,QAAI,OAAO,GAAG,UAAU,QAAQ;AAC9B,aAAO,EAAE,SAAS,OAAO,QAAQ,yBAAyB,OAAO,GAAG,OAAO,UAAU,MAAM,IAAI;AAAA,IACjG;AAEA,QAAI,OAAO,OAAO,UAAU,YAAY;AACtC,aAAO,EAAE,SAAS,OAAO,QAAQ,6BAA6B,OAAO,OAAO,OAAO,UAAU,UAAU,IAAI;AAAA,IAC7G;AAEA,WAAO,EAAE,SAAS,KAAK;AAAA,EACzB;AAAA;AAAA,EAGQ,iBACN,OACA,UACA,UACuC;AACvC,UAAM,SAAS,MAAM,SAAS,QAAQ;AAEtC,QAAI,CAAC,QAAQ;AACX,aAAO,EAAE,SAAS,OAAO,QAAQ,mBAAmB;AAAA,IACtD;AAEA,QAAI,CAAC,OAAO,OAAO;AACjB,aAAO,EAAE,SAAS,OAAO,QAAQ,sBAAsB;AAAA,IACzD;AAEA,QAAI,CAAC,OAAO,SAAS,WAAW;AAC9B,aAAO,EAAE,SAAS,OAAO,QAAQ,mCAAmC;AAAA,IACtE;AAEA,QAAI,MAAM,mBAAmB,UAAU;AACrC,aAAO,EAAE,SAAS,OAAO,QAAQ,oCAAoC;AAAA,IACvE;AAEA,QAAI,MAAM,UAAU,iBAAiB,MAAM,UAAU,sBAAsB;AACzE,aAAO,EAAE,SAAS,OAAO,QAAQ,4CAA4C;AAAA,IAC/E;AAEA,QAAI,CAAC,MAAM,eAAe;AACxB,aAAO,EAAE,SAAS,OAAO,QAAQ,gCAAgC;AAAA,IACnE;AAEA,QAAI,CAAC,MAAM,cAAc,eAAe;AACtC,aAAO,EAAE,SAAS,OAAO,QAAQ,uCAAuC;AAAA,IAC1E;AAGA,UAAM,OAAO,aAAa,QAAQ,SAAS,WAAW,KAAK;AAC3D,QAAI,CAAC,QAAQ,OAAO,eAAe,YAAY,OAAO,eAAe,UAAU,QAAQ,IAAI;AACzF,aAAO,EAAE,SAAS,OAAO,QAAQ,iCAAiC;AAAA,IACpE;AAEA,WAAO,EAAE,SAAS,KAAK;AAAA,EACzB;AAAA,EAEQ,gBACN,OACA,UACA,UACuC;AACvC,UAAM,SAAS,MAAM,SAAS,QAAQ;AAEtC,QAAI,CAAC,QAAQ;AACX,aAAO,EAAE,SAAS,OAAO,QAAQ,mBAAmB;AAAA,IACtD;AAEA,QAAI,MAAM,mBAAmB,UAAU;AACrC,aAAO,EAAE,SAAS,OAAO,QAAQ,+BAA+B;AAAA,IAClE;AAEA,UAAM,OAAO,aAAa,QAAQ,SAAS,WAAW,KAAK;AAC3D,QAAI,CAAC,QAAQ,OAAO,eAAe,YAAY,OAAO,eAAe,UAAU,QAAQ,IAAI;AACzF,aAAO,EAAE,SAAS,OAAO,QAAQ,iCAAiC;AAAA,IACpE;AAEA,WAAO,EAAE,SAAS,KAAK;AAAA,EACzB;AAAA,EAEQ,iBAAiB,MAA+B;AACtD,QAAI,KAAK,YAAY,KAAK,KAAK,YAAY,IAAI;AAC7C,aAAO;AAAA,IACT;AAEA,QAAI,KAAK,WAAW,KAAK,KAAK,WAAW,KAAK;AAC5C,aAAO;AAAA,IACT;AAEA,QAAI,KAAK,UAAU,WAAW,KAAK,WAAW;AAC5C,aAAO;AAAA,IACT;AAEA,eAAW,SAAS,KAAK,WAAW;AAClC,UAAI,QAAQ,KAAK,QAAQ,KAAK,UAAU;AACtC,eAAO,cAAc,KAAK,wBAAwB,KAAK,QAAQ;AAAA,MACjE;AACA,UAAI,CAAC,OAAO,UAAU,KAAK,GAAG;AAC5B,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,oBAAoB,MAAgB,OAAe,eAAiC;AAC1F,UAAM,cAAc,KAAK,cACrB,KAAK,IAAI,GAAG,KAAK,SAAS,IAC1B,KAAK,IAAI,GAAG,KAAK,SAAS;AAE9B,UAAM,QAAQ,cAAc,KAAK,WAAW;AAE5C,UAAM,QAAQ,GAAG,KAAK,SAAS,IAAI,KAAK,QAAQ,KAAK,KAAK,UAAU,KAAK,IAAI,CAAC,KACzE,KAAK,cAAc,YAAY,QAAQ,IAAI,WAAW,MACpD,KAAK,QAAQ,iBAAiB,aAAa,KAAK,KAAK,OAAO,KAAK;AAExE,WAAO;AAAA,MACL;AAAA,MACA,UAAU;AAAA,MACV,WAAW,KAAK;AAAA,MAChB,aAAa,KAAK;AAAA,MAClB,SAAS,KAAK;AAAA,MACd;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,uBACN,MACA,OACA,eACA,SACqB;AACrB,UAAM,aAAa,KAAK,iBAAiB,IAAI;AAC7C,QAAI,eAAe,MAAM;AACvB,aAAO,aAAa,EAAE,OAAO,WAAW,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC7D;AAEA,WAAO,KAAK,oBAAoB,MAAM,OAAO,aAAa;AAAA,EAC5D;AAAA;AAAA,EAGQ,eAAe,SAAsC;AAC3D,WAAO,CAAC,GAAG,OAAO,EACf,KAAK,CAAC,GAAG,MAAM;AACd,UAAI,EAAE,SAAS,EAAE,KAAM,QAAO,EAAE,OAAO,EAAE;AACzC,UAAI,EAAE,eAAe,EAAE,WAAY,QAAO,EAAE,aAAa,EAAE;AAC3D,UAAI,EAAE,kBAAkB,EAAE,cAAe,QAAO,EAAE,gBAAgB,EAAE;AACpE,aAAO,EAAE,SAAS,cAAc,EAAE,QAAQ;AAAA,IAC5C,CAAC,EACA,IAAI,OAAK,EAAE,QAAQ;AAAA,EACxB;AAAA;AAAA,EAGQ,oBACN,SACA,UACU;AACV,UAAM,SAAmD,EAAE,MAAM,CAAC,GAAG,OAAO,CAAC,EAAE;AAE/E,eAAW,SAAS,SAAS;AAC3B,YAAM,SAAS,SAAS,MAAM,QAAQ;AACtC,UAAI,QAAQ;AACV,eAAO,OAAO,OAAO,EAAE,KAAK,KAAK;AAAA,MACnC;AAAA,IACF;AAEA,UAAM,aAAuE,CAAC;AAE9E,eAAW,CAAC,SAAS,cAAc,KAAK,OAAO,QAAQ,MAAM,GAA2C;AACtG,UAAI,eAAe,WAAW,EAAG;AACjC,YAAM,SAAS,KAAK,eAAe,cAAc;AACjD,YAAM,YAAY,eAAe,KAAK,OAAK,EAAE,aAAa,OAAO,CAAC,CAAC;AACnE,iBAAW,KAAK,EAAE,SAAS,UAAU,CAAC;AAAA,IACxC;AAEA,eAAW,KAAK,CAAC,GAAG,MAAM;AACxB,YAAM,KAAK,EAAE;AACb,YAAM,KAAK,EAAE;AACb,UAAI,GAAG,SAAS,GAAG,KAAM,QAAO,GAAG,OAAO,GAAG;AAC7C,UAAI,GAAG,eAAe,GAAG,WAAY,QAAO,GAAG,aAAa,GAAG;AAC/D,UAAI,GAAG,kBAAkB,GAAG,cAAe,QAAO,GAAG,gBAAgB,GAAG;AACxE,aAAO,GAAG,SAAS,cAAc,GAAG,QAAQ;AAAA,IAC9C,CAAC;AAED,UAAM,SAAmB,CAAC;AAC1B,eAAW,EAAE,QAAQ,KAAK,YAAY;AACpC,aAAO,KAAK,GAAG,KAAK,eAAe,OAAO,OAAO,CAAC,CAAC;AAAA,IACrD;AACA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,MAAc,yBAAyB,YAAoB,SAAqC;AAC9F,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,KAAK,UAAU,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EACjG;AAAA;AAAA,EAGA,MAAc,yBAAyB,YAAoB,MAAe,SAAqC;AAC7G,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,iBAAiB,KAAK,mBAAmB,UAAU,UAAU;AACnE,UAAM,mBAAmB,KAAK,qBAAqB;AACnD,UAAM,WAAW,KAAK;AAEtB,QAAI,CAAC,YAAY,OAAO,KAAK,QAAQ,EAAE,WAAW,GAAG;AACnD,aAAO,aAAa,EAAE,OAAO,wBAAwB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC1E;AAEA,QAAI,kBAAmD,CAAC;AACxD,QAAI,kBAA4B,CAAC;AAGjC,QAAI,kBAAkB;AAEpB,wBAAkB,CAAC;AAAA,IACrB,OAAO;AAEL,iBAAW,CAAC,UAAU,MAAM,KAAK,OAAO,QAAQ,QAAQ,GAAG;AACzD,cAAM,OAAO,SAAS;AACtB,cAAM,aAAa,OAAO,OAAO,OAAO,eAAe,KAAK;AAC5D,wBAAgB,QAAQ,IAAI;AAAA,UAC1B;AAAA,UACA;AAAA,UACA;AAAA,UACA,eAAe,OAAO,OAAO;AAAA,QAC/B;AAAA,MACF;AAGA,wBAAkB,mBAAmB,UACjC,KAAK,oBAAoB,OAAO,OAAO,eAAe,GAAG,QAAQ,IACjE,KAAK,eAAe,OAAO,OAAO,eAAe,CAAC;AAAA,IACxD;AAEA,UAAM,OAAM,oBAAI,KAAK,GAAE,YAAY;AACnC,UAAM,WAAW,OAAO,WAAW;AAGnC,UAAM,SAAS,OAAO,QAAQ,QAAQ,EACnC,OAAO,CAAC,CAAC,GAAG,CAAC,MAAM,EAAE,YAAY,MAAM,EACvC,IAAI,CAAC,CAAC,EAAE,MAAM,EAAE;AACnB,UAAM,UAAU,OAAO,QAAQ,QAAQ,EACpC,OAAO,CAAC,CAAC,GAAG,CAAC,MAAM,EAAE,YAAY,OAAO,EACxC,IAAI,CAAC,CAAC,EAAE,MAAM,EAAE;AAGnB,UAAM,mBAAmB,KAAK,0BAA0B,QAAQ;AAEhE,UAAM,cAAwC;AAAA,MAC5C;AAAA,MACA;AAAA,MACA,OAAO,mBAAmB,uBAAuB;AAAA,MACjD,OAAO;AAAA,MACP,WAAW;AAAA,MACX;AAAA,MACA,gBAAgB,mBAAmB,OAAQ,gBAAgB,CAAC,KAAK;AAAA,MACjE;AAAA,MACA;AAAA,MACA,UAAU;AAAA,MACV,MAAM,EAAE,QAAQ,QAAQ;AAAA,MACxB,SAAS,CAAC;AAAA,MACV,eAAe;AAAA,MACf,kBAAkB,CAAC;AAAA,MACnB,sBAAsB,CAAC;AAAA,MACvB,oBAAoB,CAAC;AAAA,MACrB,qBAAqB,CAAC;AAAA,MACtB,KAAK,CAAC;AAAA,MACN,SAAS;AAAA,MACT,WAAW;AAAA,MACX,eAAe;AAAA,IACjB;AAGA,QAAI,CAAC,oBAAoB,YAAY,gBAAgB;AACnD,YAAM,eAAe,YAAY,SAAS,YAAY,cAAc;AACpE,UAAI,cAAc;AAChB,qBAAa,GAAG,UAAU,aAAa,GAAG;AAC1C,qBAAa,SAAS,YAAY;AAAA,MACpC;AAAA,IACF;AAGA,gBAAY,IAAI,KAAK,KAAK,mBAAmB,kBAAkB,QAAW,QAAW;AAAA,MACnF;AAAA,MACA;AAAA,MACA,aAAa,OAAO,KAAK,QAAQ,EAAE;AAAA,MACnC;AAAA,IACF,CAAC,CAAC;AAGF,QAAI,CAAC,oBAAoB,YAAY,gBAAgB;AACnD,kBAAY,IAAI,KAAK,KAAK,mBAAmB,gBAAgB,YAAY,gBAAgB,QAAW;AAAA,QAClG,OAAO;AAAA,QACP,WAAW;AAAA,MACb,CAAC,CAAC;AAAA,IACJ;AAEA,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AACvE,SAAK,mBAAmB,kBAAkB,YAAY,UAAU,EAAE,OAAO,YAAY,CAAC;AAEtF,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAClF;AAAA;AAAA,EAGA,MAAc,2BAA2B,YAAoB,MAAe,SAAqC;AAC/G,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,WAAW,KAAK;AACtB,UAAM,OAAO,KAAK;AAElB,QAAI,CAAC,YAAY,CAAC,MAAM;AACtB,aAAO,aAAa,EAAE,OAAO,4BAA4B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC9E;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,oBAAoB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACtE;AAEA,QAAI,YAAY,UAAU,sBAAsB;AAC9C,aAAO,aAAa,EAAE,OAAO,6CAA6C,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC/F;AAEA,UAAM,SAAS,YAAY,SAAS,QAAQ;AAC5C,QAAI,CAAC,QAAQ;AACX,aAAO,aAAa,EAAE,OAAO,oBAAoB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACtE;AAGA,UAAM,aAAa,KAAK,iBAAiB,IAAI;AAC7C,QAAI,eAAe,MAAM;AACvB,aAAO,aAAa,EAAE,OAAO,WAAW,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC7D;AAGA,UAAM,gBAAgB,OAAO,OAAO,OAAO,eAAe,KAAK;AAC/D,UAAM,aAAa,KAAK,oBAAoB,MAAM,OAAO,iBAAiB,aAAa;AAGvF,gBAAY,gBAAgB,QAAQ,IAAI;AAAA,MACtC;AAAA,MACA,MAAM,WAAW;AAAA,MACjB,YAAY;AAAA,MACZ,eAAe,OAAO,OAAO;AAAA,IAC/B;AAGA,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AACvE,SAAK,mBAAmB,6BAA6B,YAAY,UAAU;AAAA,MACzE;AAAA,MACA,UAAU;AAAA;AAAA,MACV,MAAM;AAAA,IACR,CAAC;AAGD,UAAM,eAAe,OAAO,KAAK,YAAY,QAAQ;AACrD,UAAM,kBAAkB,OAAO,KAAK,YAAY,eAAe;AAC/D,UAAM,YAAY,aAAa,MAAM,QAAM,gBAAgB,SAAS,EAAE,CAAC;AAEvE,QAAI,WAAW;AAEb,YAAM,kBAAkB,YAAY,mBAAmB,UACnD,KAAK,oBAAoB,OAAO,OAAO,YAAY,eAAe,GAAG,YAAY,QAAQ,IACzF,KAAK,eAAe,OAAO,OAAO,YAAY,eAAe,CAAC;AAElE,kBAAY,kBAAkB;AAC9B,kBAAY,QAAQ;AACpB,kBAAY,iBAAiB,gBAAgB,CAAC,KAAK;AACnD,kBAAY,YAAY;AAGxB,UAAI,YAAY,gBAAgB;AAC9B,cAAM,eAAe,YAAY,SAAS,YAAY,cAAc;AACpE,YAAI,cAAc;AAChB,uBAAa,GAAG,UAAU,aAAa,GAAG;AAC1C,uBAAa,SAAS,YAAY;AAAA,QACpC;AAAA,MACF;AAGA,UAAI,YAAY,gBAAgB;AAC9B,oBAAY,IAAI,KAAK,KAAK,mBAAmB,gBAAgB,YAAY,gBAAgB,QAAW;AAAA,UAClG,OAAO;AAAA,UACP,WAAW;AAAA,QACb,CAAC,CAAC;AAAA,MACJ;AAEA,YAAM,gBAAgB,MAAM,KAAK,oBAAoB,YAAY,WAAW;AAG5E,WAAK,mBAAmB,yBAAyB,YAAY,eAAe;AAAA,QAC1E;AAAA,QACA,aAAa,OAAO;AAAA,UAClB,OAAO,QAAQ,YAAY,eAAe,EAAE,IAAI,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI;AAAA,YACpE,OAAO,YAAY,SAAS,EAAE,GAAG,mBAAmB;AAAA,YACpD,UAAU,MAAM;AAAA,YAChB,WAAW;AAAA,YACX,aAAa;AAAA,YACb,SAAS,CAAC,MAAM,IAAI;AAAA,YACpB,aAAa,MAAM;AAAA,YACnB,OAAO,MAAM,OAAO,MAAM;AAAA,YAC1B,OAAO,UAAU,MAAM,IAAI,OAAO,MAAM,UAAU,MAAM,MAAM,OAAO,MAAM,UAAU;AAAA,UACvF,CAAC,CAAC;AAAA,QACJ;AAAA,MACF,CAAC;AAED,aAAO,aAAa,EAAE,IAAI,MAAM,UAAU,eAAe,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACjG;AAEA,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAClF;AAAA;AAAA,EAGA,MAAc,oBAAoB,YAAoB,MAAe,SAAqC;AACxG,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,WAAW,yBAAyB,KAAK,UAAU,YAAY,OAAO;AAC5E,QAAI,oBAAoB,SAAU,QAAO;AAEzC,UAAM,WAAW,yBAAyB,KAAK,UAAU,YAAY,OAAO;AAC5E,QAAI,oBAAoB,SAAU,QAAO;AAEzC,UAAM,aAAc,KAAK,QAAuB;AAChD,UAAM,iBAAiB,iBAAiB,KAAK,gBAAgB,kBAAkB,OAAO,OAAO;AAC7F,QAAI,0BAA0B,SAAU,QAAO;AAE/C,UAAM,SAAS,iBAAiB,KAAK,QAAQ,UAAU,GAAG,OAAO;AACjE,QAAI,kBAAkB,SAAU,QAAO;AAEvC,UAAM,aAAa,iBAAiB,KAAK,YAAY,cAAc,GAAG,OAAO;AAC7E,QAAI,sBAAsB,SAAU,QAAO;AAE3C,UAAM,gBAAgB,KAAK,kBAAkB;AAG7C,UAAM,aAAa,KAAK,eAAe,aAAa,UAAU,UAAU,QAAQ,UAAU;AAC1F,QAAI,CAAC,WAAW,SAAS;AACvB,YAAMA,YAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AACvE,WAAK,mBAAmB,mBAAmB,YAAYA,WAAU;AAAA,QAC/D;AAAA,QACA,QAAQ,WAAW;AAAA,MACrB,CAAC;AACD,aAAO,aAAa,EAAE,IAAI,OAAO,OAAO,WAAW,OAAO,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC/E;AAGA,UAAM,SAAS,YAAY,SAAS,QAAQ;AAC5C,WAAO,GAAG,WAAW;AACrB,WAAO,OAAO,WAAW;AAGzB,UAAM,gBAA+B;AAAA,MACnC,UAAU,OAAO,WAAW;AAAA,MAC5B,MAAM;AAAA,MACN,gBAAgB;AAAA,MAChB,gBAAgB,kBAAkB;AAAA,MAClC;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,UAAU,KAAK;AAAA,IACjB;AAEA,gBAAY,gBAAgB;AAC5B,gBAAY,IAAI,KAAK,KAAK,mBAAmB,mBAAmB,UAAU,kBAAkB,QAAW;AAAA,MACrG;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC,CAAC;AAEF,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AACvE,SAAK,mBAAmB,mBAAmB,YAAY,UAAU;AAAA,MAC/D,QAAQ;AAAA,MACR,OAAO,YAAY;AAAA,MACnB,OAAO;AAAA,IACT,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,aAAa,QAAQ,cAAc,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EACzG;AAAA;AAAA,EAGA,MAAc,sBAAsB,YAAoB,MAAe,SAAqC;AAC1G,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,WAAW,yBAAyB,KAAK,UAAU,YAAY,OAAO;AAC5E,QAAI,oBAAoB,SAAU,QAAO;AAEzC,UAAM,WAAW,yBAAyB,KAAK,UAAU,YAAY,OAAO;AAC5E,QAAI,oBAAoB,SAAU,QAAO;AAEzC,UAAM,eAAgB,KAAK,QAAyB;AAEpD,UAAM,SAAS,iBAAiB,KAAK,QAAQ,UAAU,GAAG,OAAO;AACjE,QAAI,kBAAkB,SAAU,QAAO;AAEvC,UAAM,aAAa,iBAAiB,KAAK,YAAY,cAAc,GAAG,OAAO;AAC7E,QAAI,sBAAsB,SAAU,QAAO;AAG3C,UAAM,aAAa,KAAK,iBAAiB,aAAa,UAAU,QAAQ;AACxE,QAAI,CAAC,WAAW,SAAS;AACvB,YAAMA,YAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AACvE,WAAK,mBAAmB,qBAAqB,YAAYA,WAAU;AAAA,QACjE;AAAA,QACA,QAAQ,WAAW;AAAA,MACrB,CAAC;AACD,aAAO,aAAa,EAAE,IAAI,OAAO,OAAO,WAAW,OAAO,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC/E;AAGA,UAAM,SAAS,YAAY,SAAS,QAAQ;AAC5C,QAAI,OAAO,GAAG,UAAU,QAAQ;AAC9B,aAAO,aAAa,EAAE,IAAI,OAAO,OAAO,+BAA+B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5F;AAGA,WAAO,GAAG,WAAW;AACrB,WAAO,OAAO,UAAU,KAAK,IAAI,GAAG,OAAO,OAAO,UAAU,UAAU;AACtE,WAAO,SAAS,YAAY;AAG5B,UAAM,kBAAmC;AAAA,MACvC,YAAY,OAAO,WAAW;AAAA,MAC9B;AAAA,MACA,MAAM;AAAA,MACN,gBAAgB,YAAY,cAAe;AAAA,MAC3C,OAAO,KAAK;AAAA,MACZ;AAAA,MACA;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,SAAS,KAAK;AAAA,IAChB;AAEA,gBAAY,iBAAiB,KAAK,eAAe;AAGjD,QAAI,YAAY,UAAU,eAAe;AACvC,kBAAY,QAAQ;AAAA,IACtB;AAEA,gBAAY,IAAI,KAAK,KAAK,mBAAmB,qBAAqB,UAAU,QAAW;AAAA,MACrF;AAAA,MACA,gBAAgB,gBAAgB;AAAA,MAChC;AAAA,MACA;AAAA,IACF,CAAC,CAAC;AAEF,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AACvE,SAAK,mBAAmB,qBAAqB,YAAY,UAAU;AAAA,MACjE,UAAU;AAAA,MACV,uBAAuB,YAAY,iBAAiB;AAAA,MACpD,OAAO;AAAA,IACT,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,aAAa,UAAU,gBAAgB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAC7G;AAAA;AAAA,EAGA,MAAc,uBAAuB,YAAoB,MAAe,SAAqC;AAC3G,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,WAAW,yBAAyB,KAAK,UAAU,YAAY,OAAO;AAC5E,QAAI,oBAAoB,SAAU,QAAO;AAEzC,UAAM,OAAO,aAAa,QAAQ,SAAS,WAAW,KAAK;AAC3D,QAAI,CAAC,MAAM;AACT,aAAO,aAAa,EAAE,OAAO,iCAAiC,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACnF;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,QAAI,CAAC,YAAY,eAAe;AAC9B,aAAO,aAAa,EAAE,OAAO,gCAAgC,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAClF;AAGA,gBAAY,QAAQ;AAGpB,UAAM,eAAe,YAAY,gBAAgB;AAAA,MAAO,QACtD,YAAY,iBAAiB,KAAK,OAAK,EAAE,aAAa,EAAE;AAAA,IAC1D;AAEA,UAAM,kBAAkB,aACrB,IAAI,QAAM,YAAY,iBAAiB,KAAK,OAAK,EAAE,aAAa,EAAE,CAAE,EACpE,OAAO,OAAO;AAEjB,QAAI,kBAAkB;AACtB,QAAI,iBAAiB;AACrB,UAAM,oBAAuG,CAAC;AAG9G,eAAW,YAAY,iBAAiB;AAEtC,YAAM,UAAU;AAChB,YAAM,UAAU,SAAS,WAAW,CAAC;AAGrC,iBAAW,UAAU,SAAS;AAC5B,gBAAQ,OAAO,MAAM;AAAA,UACnB,KAAK;AACH,8BAAkB;AAClB;AAAA,UACF,KAAK;AACH,6BAAiB;AACjB;AAAA,UACF,KAAK;AACH,gBAAI,OAAO,MAAM,QAAQ;AACvB,oBAAM,SAAS,YAAY,SAAS,OAAO,cAAc;AACzD,kBAAI,QAAQ;AACV,2BAAW,CAAC,WAAW,KAAK,KAAK,OAAO,QAAQ,OAAO,KAAK,MAAM,GAAG;AACnE,wBAAM,UAAU,OAAO,OAAO,SAAsB,KAAK;AACzD,yBAAO,OAAO,SAAsB,IAAI,UAAW;AAAA,gBACrD;AACA,4BAAY,IAAI,KAAK,KAAK,mBAAmB,kBAAkB,SAAS,UAAU,OAAO,gBAAgB;AAAA,kBACvG,QAAQ,OAAO,KAAK;AAAA,kBACpB,QAAQ;AAAA,gBACV,CAAC,CAAC;AAAA,cACJ;AAAA,YACF;AACA;AAAA,UACF,KAAK;AACH,gBAAI,OAAO,MAAM,WAAW;AAC1B,oBAAM,SAAS,YAAY,SAAS,OAAO,cAAc;AACzD,kBAAI,QAAQ;AACV,uBAAO,cAAc,KAAK;AAAA,kBACxB,KAAK,OAAO,KAAK;AAAA,kBACjB,QAAQ,OAAO,KAAK,gBAAgB;AAAA,kBACpC,UAAU,OAAO,KAAK,kBAAkB;AAAA,gBAC1C,CAAC;AACD,4BAAY,IAAI,KAAK,KAAK,mBAAmB,kBAAkB,SAAS,UAAU,OAAO,gBAAgB;AAAA,kBACvG,WAAW,OAAO,KAAK;AAAA,kBACvB,QAAQ,OAAO,KAAK,gBAAgB;AAAA,kBACpC,UAAU,OAAO,KAAK,kBAAkB;AAAA,gBAC1C,CAAC,CAAC;AAAA,cACJ;AAAA,YACF;AACA;AAAA,QACJ;AAAA,MACF;AAEA,wBAAkB,KAAK,EAAE,UAAU,SAAS,QAAQ,CAAC;AAErD,kBAAY,IAAI,KAAK,KAAK,mBAAmB,qBAAqB,SAAS,UAAU,QAAW;AAAA,QAC9F,YAAY,SAAS;AAAA,QACrB;AAAA,QACA,aAAa,QAAQ;AAAA,MACvB,CAAC,CAAC;AAAA,IACJ;AAGA,gBAAY,mBAAmB,CAAC;AAGhC,QAAI,iBAAiB;AACnB,kBAAY,IAAI,KAAK,KAAK,mBAAmB,oBAAoB,YAAY,cAAc,gBAAgB,QAAW;AAAA,QACpH,UAAU,YAAY,cAAc;AAAA,QACpC,QAAQ;AAAA,MACV,CAAC,CAAC;AAAA,IACJ,OAAO;AACL,kBAAY,IAAI,KAAK,KAAK,mBAAmB,mBAAmB,YAAY,cAAc,gBAAgB,YAAY,cAAc,gBAAgB;AAAA,QAClJ,UAAU,YAAY,cAAc;AAAA,QACpC,UAAU;AAAA,MACZ,CAAC,CAAC;AAAA,IACJ;AAGA,UAAM,iBAAiB,YAAY;AACnC,gBAAY,gBAAgB;AAG5B,gBAAY,QAAQ;AAEpB,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AACvE,SAAK,mBAAmB,sBAAsB,YAAY,UAAU;AAAA,MAClE,WAAW;AAAA,MACX,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA,OAAO;AAAA,IACT,CAAC;AAED,WAAO,aAAa;AAAA,MAClB,IAAI;AAAA,MACJ;AAAA,MACA,OAAO;AAAA,MACP,WAAW;AAAA,MACX;AAAA,MACA;AAAA,IACF,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EACrB;AAAA;AAAA,EAGA,MAAc,2BAA2B,YAAoB,MAAe,SAAqC;AAC/G,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,QAAI,YAAY,UAAU,aAAa;AACrC,aAAO,aAAa,EAAE,OAAO,4BAA4B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC9E;AAEA,UAAM,WAAW,yBAAyB,KAAK,UAAU,YAAY,OAAO;AAC5E,QAAI,oBAAoB,SAAU,QAAO;AAEzC,UAAM,WAAW,yBAAyB,KAAK,UAAU,YAAY,OAAO;AAC5E,QAAI,oBAAoB,SAAU,QAAO;AAEzC,UAAM,aAAa,KAAK,gBAAgB,aAAa,UAAU,QAAQ;AACvE,QAAI,CAAC,WAAW,SAAS;AACvB,aAAO,aAAa,EAAE,OAAO,WAAW,OAAO,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACpE;AAGA,QAAI,YAAY,eAAe;AAC7B,kBAAY,gBAAgB;AAC5B,kBAAY,mBAAmB,CAAC;AAAA,IAClC;AAEA,UAAM,mBAAmB,YAAY;AACrC,UAAM,iBAAiB,mBAAmB,YAAY,SAAS,gBAAgB,IAAI;AAGnF,QAAI,kBAAkB;AACpB,YAAM,YAAY,KAAK,cAAc;AACrC,kBAAY,IAAI,KAAK,KAAK,mBAAmB,cAAc,kBAAkB,QAAW;AAAA,QACtF,OAAO,YAAY;AAAA,QACnB,WAAW,YAAY;AAAA,QACvB;AAAA,MACF,CAAC,CAAC;AAAA,IACJ;AAGA,QAAI,YAAY,YAAY,YAAY;AACxC,QAAI,YAAY,YAAY;AAE5B,QAAI,aAAa,YAAY,gBAAgB,QAAQ;AACnD,kBAAY;AACZ,mBAAa;AAGb,iBAAW,UAAU,OAAO,OAAO,YAAY,QAAQ,GAAG;AACxD,eAAO,SAAS,YAAY;AAAA,MAC9B;AAEA,kBAAY,IAAI,KAAK,KAAK,mBAAmB,iBAAiB,QAAW,QAAW;AAAA,QAClF,OAAO;AAAA,MACT,CAAC,CAAC;AAAA,IACJ;AAEA,gBAAY,YAAY;AACxB,gBAAY,QAAQ;AACpB,gBAAY,iBAAiB,YAAY,gBAAgB,SAAS,KAAK;AACvE,gBAAY,QAAQ;AAGpB,QAAI,YAAY,gBAAgB;AAC9B,YAAM,eAAe,YAAY,SAAS,YAAY,cAAc;AACpE,UAAI,cAAc;AAChB,qBAAa,GAAG,UAAU,aAAa,GAAG;AAE1C,oBAAY,IAAI,KAAK,KAAK,mBAAmB,gBAAgB,YAAY,gBAAgB,QAAW;AAAA,UAClG,OAAO,YAAY;AAAA,UACnB,WAAW,YAAY;AAAA,UACvB,YAAY,aAAa,GAAG;AAAA,QAC9B,CAAC,CAAC;AAAA,MACJ;AAAA,IACF;AAEA,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AACvE,SAAK,mBAAmB,cAAc,YAAY,UAAU;AAAA,MAC1D,UAAU,oBAAoB;AAAA,MAC9B,YAAY,gBAAgB,eAAe,gBAAgB,QAAQ;AAAA,MACnE,QAAQ,KAAK,cAAc,QAAQ,UAAU;AAAA,MAC7C,cAAc;AAAA,IAChB,CAAC;AACD,SAAK,mBAAmB,cAAc,YAAY,UAAU;AAAA,MAC1D,OAAO;AAAA,IACT,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAClF;AAAA;AAAA,EAGA,MAAc,iBAAiB,YAAoB,MAAe,SAAqC;AACrG,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,OAAO,yBAAyB,KAAK,MAAM,QAAQ,OAAO;AAChE,QAAI,gBAAgB,SAAU,QAAO;AAErC,UAAM,eAAe,KAAK;AAC1B,QAAI,CAAC,cAAc;AACjB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,iBAAiB,iBAAiB,KAAK,gBAAgB,kBAAkB,OAAO,OAAO;AAC7F,QAAI,0BAA0B,SAAU,QAAO;AAE/C,UAAM,SAAS,iBAAiB,KAAK,QAAQ,UAAU,OAAO,OAAO;AACrE,QAAI,kBAAkB,SAAU,QAAO;AAEvC,UAAM,WAAuB;AAAA,MAC3B,MAAM;AAAA,MACN;AAAA,MACA,gBAAgB,kBAAkB;AAAA,MAClC,MAAM,KAAK;AAAA,MACX,QAAQ,UAAU;AAAA,MAClB,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC;AAGA,YAAQ,cAAc;AAAA,MACpB,KAAK;AACH,YAAI,kBAAkB,YAAY,SAAS,cAAc,GAAG;AAC1D,gBAAM,QAAQ,iBAAiB,KAAK,MAAM,SAAS,KAAK,MAAM,QAAQ,SAAS,GAAG,OAAO;AACzF,cAAI,OAAO,UAAU,UAAU;AAC7B,kBAAM,SAAS,YAAY,SAAS,cAAc;AAClD,mBAAO,GAAG,UAAU,KAAK,IAAI,GAAG,KAAK,IAAI,OAAO,GAAG,KAAK,OAAO,GAAG,UAAU,KAAK,CAAC;AAAA,UACpF;AAAA,QACF;AACA;AAAA,MAEF,KAAK;AACH,YAAI,kBAAkB,YAAY,SAAS,cAAc,GAAG;AAC1D,gBAAM,QAAQ,iBAAiB,KAAK,MAAM,SAAS,KAAK,MAAM,QAAQ,SAAS,GAAG,OAAO;AACzF,cAAI,OAAO,UAAU,UAAU;AAC7B,kBAAM,SAAS,YAAY,SAAS,cAAc;AAClD,mBAAO,OAAO,UAAU,KAAK,IAAI,GAAG,KAAK,IAAI,OAAO,OAAO,KAAK,OAAO,OAAO,UAAU,KAAK,CAAC;AAAA,UAChG;AAAA,QACF;AACA;AAAA,MAEF,KAAK;AACH,YAAI,YAAY,mBAAmB,gBAAgB;AAEjD,gBAAM,aAAa,YAAY,YAAY,KAAK,YAAY,gBAAgB;AAC5E,cAAI,YAAY,YAAY,WAAW;AACrC,wBAAY,SAAS;AAAA,UACvB;AACA,sBAAY,YAAY;AACxB,sBAAY,iBAAiB,YAAY,gBAAgB,SAAS,KAAK;AAAA,QACzE;AACA;AAAA,MAEF,KAAK;AAEH,cAAM,WAAW,YAAY,YAAY,KAAK,YAAY,gBAAgB;AAC1E,YAAI,UAAU,YAAY,WAAW;AACnC,sBAAY,SAAS;AACrB,qBAAW,UAAU,OAAO,OAAO,YAAY,QAAQ,GAAG;AACxD,mBAAO,SAAS,YAAY;AAAA,UAC9B;AAAA,QACF;AACA,oBAAY,YAAY;AACxB,oBAAY,iBAAiB,YAAY,gBAAgB,OAAO,KAAK;AACrE,YAAI,YAAY,gBAAgB;AAC9B,gBAAM,eAAe,YAAY,SAAS,YAAY,cAAc;AACpE,cAAI,cAAc;AAChB,yBAAa,GAAG,UAAU,aAAa,GAAG;AAAA,UAC5C;AAAA,QACF;AACA;AAAA,MAEF,KAAK;AACH,YAAI,MAAM,QAAQ,KAAK,MAAM,QAAQ,GAAG;AACtC,sBAAY,kBAAkB,KAAK,KAAK;AAAA,QAC1C;AACA;AAAA,MAEF,KAAK;AACH,YAAI,kBAAkB,YAAY,SAAS,cAAc,KAAK,KAAK,MAAM,WAAW;AAClF,sBAAY,SAAS,cAAc,EAAE,cAAc,KAAK;AAAA,YACtD,KAAK,KAAK,KAAK;AAAA,YACf,QAAS,KAAK,KAAK,UAAqB;AAAA,YACxC,UAAW,KAAK,KAAK,YAAuB;AAAA,UAC9C,CAAC;AAAA,QACH;AACA;AAAA,MAEF,KAAK;AACH,YAAI,kBAAkB,YAAY,SAAS,cAAc,KAAK,KAAK,MAAM,WAAW;AAClF,sBAAY,SAAS,cAAc,EAAE,gBACnC,YAAY,SAAS,cAAc,EAAE,cAAc;AAAA,YACjD,OAAK,EAAE,QAAQ,KAAK,MAAM;AAAA,UAC5B;AAAA,QACJ;AACA;AAAA,MAEF,KAAK;AACH,YAAI,kBAAkB,YAAY,SAAS,cAAc,GAAG;AAC1D,cAAI,KAAK,MAAM,QAAQ;AACrB,kBAAM,SAAS,KAAK,KAAK;AACzB,uBAAW,CAAC,WAAW,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AACvD,0BAAY,SAAS,cAAc,EAAE,OAAO,SAAsB,IAAI;AAAA,YACxE;AAAA,UACF,WAAW,KAAK,MAAM,aAAa,KAAK,MAAM,UAAU,QAAW;AACjE,wBAAY,SAAS,cAAc,EAAE,OAAO,KAAK,KAAK,SAAsB,IAC1E,KAAK,KAAK;AAAA,UACd;AAAA,QACF;AACA;AAAA,MAEF,KAAK;AACH,YAAI,KAAK,MAAM,OAAO;AACpB,sBAAY,QAAQ,KAAK,KAAK;AAAA,QAChC;AACA;AAAA,MAEF,KAAK;AACH,YAAI,KAAK,MAAM,YAAY;AACzB,sBAAY,mBAAmB,YAAY,iBAAiB;AAAA,YAC1D,OAAK,EAAE,eAAe,KAAK,MAAM;AAAA,UACnC;AAAA,QACF;AACA;AAAA,MAEF,KAAK;AACH,oBAAY,QAAQ;AACpB;AAAA,IACJ;AAGA,gBAAY,IAAI,KAAK,KAAK,mBAAmB,eAAe,QAAW,kBAAkB,QAAW;AAAA,MAClG;AAAA,MACA;AAAA,MACA,QAAQ,UAAU;AAAA,MAClB,MAAM,KAAK;AAAA,IACb,CAAC,CAAC;AAEF,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AACvE,SAAK,mBAAmB,eAAe,YAAY,UAAU;AAAA,MAC3D;AAAA,MACA,OAAO;AAAA,IACT,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,aAAa,SAAS,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAC5F;AAAA;AAAA,EAGA,MAAc,gBAAgB,YAAoB,MAAe,SAAqC;AACpG,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,SAAU,KAAK,UAAgD;AAErE,gBAAY,QAAQ;AACpB,gBAAY,gBAAgB;AAC5B,gBAAY,mBAAmB,CAAC;AAEhC,gBAAY,IAAI,KAAK,KAAK,mBAAmB,gBAAgB,QAAW,QAAW;AAAA,MACjF;AAAA,MACA,OAAO,YAAY;AAAA,MACnB,WAAW,YAAY;AAAA,IACzB,CAAC,CAAC;AAEF,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AACvE,SAAK,mBAAmB,gBAAgB,YAAY,UAAU;AAAA,MAC5D,UAAU,YAAY;AAAA,MACtB;AAAA,MACA,UAAU,YAAY;AAAA,MACtB,OAAO;AAAA,IACT,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,aAAa,OAAO,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAC1F;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,2BACZ,YACA,MACA,SACmB;AACnB,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,oBAAoB,yBAAyB,KAAK,mBAAmB,qBAAqB,OAAO;AACvG,QAAI,6BAA6B,SAAU,QAAO;AAElD,UAAM,iBAAiB,yBAAyB,KAAK,gBAAgB,kBAAkB,OAAO;AAC9F,QAAI,0BAA0B,SAAU,QAAO;AAE/C,UAAM,QAAQ,yBAAyB,KAAK,OAAO,SAAS,OAAO;AACnE,QAAI,iBAAiB,SAAU,QAAO;AAEtC,UAAM,YAAY,YAAY,SAAS,iBAAiB;AACxD,UAAM,SAAS,YAAY,SAAS,cAAc;AAElD,QAAI,CAAC,WAAW;AACd,aAAO,aAAa,EAAE,OAAO,8BAA8B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAChF;AACA,QAAI,CAAC,QAAQ;AACX,aAAO,aAAa,EAAE,OAAO,2BAA2B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC7E;AAGA,UAAM,OAAO,KAAK;AAClB,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,qBAAqB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACvE;AAEA,UAAM,gBAAgB,UAAU,OAAO,KAAK,KAAK;AACjD,UAAM,WAAW,KAAK,uBAAuB,MAAkB,OAAO,eAAe,OAAO;AAC5F,QAAI,oBAAoB,SAAU,QAAO;AAGzC,UAAM,YAAY,OAAO,WAAW;AACpC,UAAM,UAA+B;AAAA,MACnC;AAAA,MACA,aAAa;AAAA,MACb,gBAAgB;AAAA,MAChB,eAAe;AAAA,MACf,UAAU;AAAA,MACV,iBAAiB,OAAO,mBAAmB;AAAA,MAC3C,QAAQ;AAAA,MACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC;AAEA,gBAAY,qBAAqB,SAAS,IAAI;AAG9C,QAAI,QAAQ,mBAAmB,OAAO,qBAAqB;AACzD,aAAO,KAAK,mBAAmB,YAAY,aAAa,SAAS,QAAQ,OAAO;AAAA,IAClF;AAEA,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AAGvE,SAAK,mBAAmB,2BAA2B,YAAY,UAAU;AAAA,MACvE;AAAA,MACA,eAAe,UAAU,eAAe,UAAU;AAAA,MAClD,YAAY,OAAO,eAAe,OAAO;AAAA,IAC3C,CAAC;AAGD,QAAI,OAAO,WAAW,WAAW,SAAS,GAAG;AAC3C,YAAM,iBAAiB,OAAO,WAAW,QAAQ,WAAW,EAAE;AAC9D,WAAK,mBAAmB,mCAAmC,YAAY,UAAU;AAAA,QAC/E;AAAA,QACA;AAAA,QACA;AAAA,QACA,eAAe,UAAU,eAAe,UAAU;AAAA,QAClD,gBAAgB;AAAA,QAChB,gBAAgB,SAAS;AAAA,MAC3B,CAAC;AAAA,IACH;AAEA,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,aAAa,UAAU,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAC7F;AAAA,EAEA,MAAc,0BACZ,YACA,MACA,SACmB;AACnB,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,YAAY,yBAAyB,KAAK,WAAW,aAAa,OAAO;AAC/E,QAAI,qBAAqB,SAAU,QAAO;AAE1C,UAAM,WAAW,yBAAyB,KAAK,UAAU,YAAY,OAAO;AAC5E,QAAI,oBAAoB,SAAU,QAAO;AAEzC,UAAM,QAAQ,yBAAyB,KAAK,OAAO,SAAS,OAAO;AACnE,QAAI,iBAAiB,SAAU,QAAO;AAEtC,UAAM,UAAU,YAAY,qBAAqB,SAAS;AAC1D,QAAI,CAAC,SAAS;AACZ,aAAO,aAAa,EAAE,OAAO,qBAAqB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACvE;AAEA,QAAI,QAAQ,WAAW,oBAAoB;AACzC,aAAO,aAAa,EAAE,OAAO,4BAA4B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC9E;AAEA,UAAM,WAAW,YAAY,SAAS,QAAQ;AAC9C,QAAI,CAAC,UAAU;AACb,aAAO,aAAa,EAAE,OAAO,6BAA6B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC/E;AAGA,UAAM,OAAO,KAAK;AAClB,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,qBAAqB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACvE;AAEA,UAAM,gBAAgB,SAAS,OAAO,KAAK,KAAK;AAChD,UAAM,WAAW,KAAK,uBAAuB,MAAkB,OAAO,eAAe,OAAO;AAC5F,QAAI,oBAAoB,SAAU,QAAO;AAGzC,UAAM,UAAU,KAAK,oBAAoB,QAAQ,eAAe,QAAQ;AACxE,YAAQ,gBAAgB;AACxB,YAAQ,eAAe;AACvB,YAAQ,UAAU;AAClB,YAAQ,SAAS;AACjB,YAAQ,cAAa,oBAAI,KAAK,GAAE,YAAY;AAE5C,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AAEvE,UAAM,YAAY,YAAY,SAAS,QAAQ,WAAW;AAC1D,UAAM,QAAQ,GAAG,UAAU,eAAe,UAAU,IAAI,KAAK,QAAQ,cAAc,KAAK,QAAQ,SAAS,eAAe,SAAS,IAAI,KAAK,SAAS,KAAK,OAAO,QAAQ,QAAQ,QAAS,QAAQ,aAAa,cAAc,mBAAmB,eAAgB,KAAK,QAAQ,aAAa,YAAY,CAAC;AAErS,SAAK,mBAAmB,0BAA0B,YAAY,UAAU;AAAA,MACtE;AAAA,MACA;AAAA,MACA,eAAe,UAAU,eAAe,UAAU;AAAA,MAClD,YAAY,SAAS,eAAe,SAAS;AAAA,MAC7C;AAAA,IACF,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,aAAa,QAAQ,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAC3F;AAAA,EAEA,MAAc,wBACZ,YACA,MACA,SACmB;AACnB,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,iBAAiB,yBAAyB,KAAK,gBAAgB,kBAAkB,OAAO;AAC9F,QAAI,0BAA0B,SAAU,QAAO;AAE/C,UAAM,iBAAiB,yBAAyB,KAAK,gBAAgB,kBAAkB,OAAO;AAC9F,QAAI,0BAA0B,SAAU,QAAO;AAE/C,UAAM,QAAQ,yBAAyB,KAAK,OAAO,SAAS,OAAO;AACnE,QAAI,iBAAiB,SAAU,QAAO;AAEtC,UAAM,eAAe,KAAK,iBAAiB,SAAY,iBAAiB,KAAK,cAAc,gBAAgB,QAAW,OAAO,IAAI;AAEjI,UAAM,SAAS,YAAY,SAAS,cAAc;AAClD,QAAI,CAAC,QAAQ;AACX,aAAO,aAAa,EAAE,OAAO,oBAAoB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACtE;AAGA,UAAM,UAAU,OAAO,WAAW;AAClC,UAAM,QAA2B;AAAA,MAC/B;AAAA,MACA,aAAa;AAAA;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAc,OAAO,iBAAiB,WAAW,eAAe;AAAA,MAChE,QAAQ;AAAA,MACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC;AAEA,gBAAY,mBAAmB,OAAO,IAAI;AAE1C,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AAEvE,SAAK,mBAAmB,yBAAyB,YAAY,UAAU;AAAA,MACrE;AAAA,MACA,kBAAkB;AAAA,MAClB,YAAY,OAAO,eAAe,OAAO;AAAA,MACzC;AAAA,MACA;AAAA;AAAA,IACF,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,aAAa,QAAQ,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAC3F;AAAA,EAEA,MAAc,uBACZ,YACA,MACA,SACmB;AACnB,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,UAAU,yBAAyB,KAAK,SAAS,WAAW,OAAO;AACzE,QAAI,mBAAmB,SAAU,QAAO;AAExC,UAAM,QAAQ,YAAY,mBAAmB,OAAO;AACpD,QAAI,CAAC,OAAO;AACV,aAAO,aAAa,EAAE,OAAO,yBAAyB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC3E;AAEA,QAAI,MAAM,WAAW,WAAW;AAC9B,aAAO,aAAa,EAAE,OAAO,iCAAiC,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACnF;AAEA,UAAM,SAAS,YAAY,SAAS,MAAM,cAAc;AACxD,QAAI,CAAC,QAAQ;AACX,aAAO,aAAa,EAAE,OAAO,oBAAoB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACtE;AAGA,UAAM,OAAO,KAAK;AAClB,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,qBAAqB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACvE;AAEA,UAAM,gBAAgB,OAAO,OAAO,MAAM,KAAK,KAAK;AACpD,UAAM,WAAW,KAAK,uBAAuB,MAAkB,MAAM,OAAO,eAAe,OAAO;AAClG,QAAI,oBAAoB,SAAU,QAAO;AAEzC,UAAM,WAAW;AACjB,UAAM,SAAS;AACf,UAAM,cAAa,oBAAI,KAAK,GAAE,YAAY;AAE1C,UAAM,UAAU,MAAM,iBAAiB,SAAY,SAAS,SAAS,MAAM,eAAe;AAE1F,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AAEvE,SAAK,mBAAmB,sBAAsB,YAAY,UAAU;AAAA,MAClE;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,aAAa,UAAU,QAAQ,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EACrG;AAAA,EAEA,MAAc,mBACZ,YACA,MACA,SACmB;AACnB,QAAI,CAAC,SAAS,IAAI,GAAG;AACnB,aAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACrE;AAEA,UAAM,cAAc,MAAM,KAAK,oBAAoB,UAAU;AAC7D,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,EAAE,OAAO,0BAA0B,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IAC5E;AAEA,UAAM,WAAW,yBAAyB,KAAK,UAAU,YAAY,OAAO;AAC5E,QAAI,oBAAoB,SAAU,QAAO;AAEzC,UAAM,SAAS,YAAY,SAAS,QAAQ;AAC5C,QAAI,CAAC,QAAQ;AACX,aAAO,aAAa,EAAE,OAAO,oBAAoB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACtE;AAGA,QAAI,YAAY,mBAAmB,UAAU;AAC3C,aAAO,aAAa,EAAE,OAAO,qDAAqD,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACvG;AAEA,UAAM,SAAU,KAAK,UAAiD;AACtE,UAAM,aAAa,OAAO,eAAe,OAAO;AAGhD,WAAO,YAAY,SAAS,QAAQ;AAGpC,gBAAY,kBAAkB,YAAY,gBAAgB,OAAO,QAAM,OAAO,QAAQ;AAGtF,gBAAY,KAAK,SAAS,YAAY,KAAK,OAAO,OAAO,QAAM,OAAO,QAAQ;AAC9E,gBAAY,KAAK,UAAU,YAAY,KAAK,QAAQ,OAAO,QAAM,OAAO,QAAQ;AAGhF,UAAM,eAAe,YAAY,gBAAgB,QAAQ,QAAQ;AACjE,QAAI,iBAAiB,MAAM,eAAe,YAAY,WAAW;AAC/D,kBAAY,YAAY,KAAK,IAAI,GAAG,YAAY,YAAY,CAAC;AAAA,IAC/D;AAEA,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AAEvE,SAAK,mBAAmB,kBAAkB,YAAY,UAAU;AAAA,MAC9D;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,YAAY,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAClF;AAAA;AAAA;AAAA;AAAA,EAMQ,sBAAsB,aAAqB,YAAkC;AACnF,QAAI,cAAc,EAAG,QAAO;AAC5B,UAAM,QAAQ,cAAc;AAC5B,QAAI,SAAS,EAAK,QAAO;AACzB,QAAI,SAAS,EAAK,QAAO;AACzB,QAAI,SAAS,IAAK,QAAO;AACzB,WAAO;AAAA,EACT;AAAA,EAEQ,oBAAoB,eAAyB,cAAwC;AAC3F,UAAM,iBAAiB,cAAc;AACrC,UAAM,gBAAgB,aAAa;AAEnC,QAAI,mBAAmB,eAAe;AACpC,aAAO;AAAA,QACL,UAAU;AAAA,QACV,SAAS;AAAA,QACT,aAAa;AAAA,QACb,YAAY;AAAA,QACZ,cAAc;AAAA,QACd,OAAO;AAAA,MACT;AAAA,IACF;AAEA,UAAM,gBAAgB,iBAAiB;AACvC,UAAM,cAAc,gBAAgB,iBAAiB;AACrD,UAAM,aAAa,gBAAgB,gBAAgB;AAEnD,WAAO;AAAA,MACL,UAAU,gBAAgB,cAAc;AAAA,MACxC,SAAS,gBAAgB,aAAa;AAAA,MACtC;AAAA,MACA;AAAA,MACA,cAAc,KAAK,sBAAsB,aAAa,UAAU;AAAA,MAChE,OAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,MAAc,mBACZ,YACA,aACA,SACA,UACA,SACmB;AACnB,UAAM,eAAe,SAAS;AAC9B,UAAM,gBAAgB,SAAS,OAAO,YAAY,KAAK;AAGvD,UAAM,WAAW,KAAK,MAAM,KAAK,OAAO,IAAI,GAAG,IAAI;AACnD,UAAM,eAAyB;AAAA,MAC7B,OAAO;AAAA,MACP,UAAU;AAAA,MACV,WAAW;AAAA,MACX,aAAa;AAAA,MACb,SAAS,CAAC,QAAQ;AAAA,MAClB,aAAa;AAAA,MACb,OAAO,WAAW;AAAA,MAClB,OAAO,UAAU,QAAQ,OAAO,aAAa,MAAM,WAAW,aAAa;AAAA,IAC7E;AAGA,UAAM,UAAU,KAAK,oBAAoB,QAAQ,eAAe,YAAY;AAC5E,YAAQ,gBAAgB;AACxB,YAAQ,eAAe;AACvB,YAAQ,UAAU;AAClB,YAAQ,SAAS;AACjB,YAAQ,cAAa,oBAAI,KAAK,GAAE,YAAY;AAE5C,UAAM,WAAW,MAAM,KAAK,oBAAoB,YAAY,WAAW;AAEvE,UAAM,YAAY,YAAY,SAAS,QAAQ,WAAW;AAC1D,UAAM,QAAQ,GAAG,UAAU,eAAe,UAAU,IAAI,KAAK,QAAQ,cAAc,KAAK,QAAQ,SAAS,eAAe,SAAS,IAAI,KAAK,aAAa,KAAK,cAAc,QAAQ,QAAQ,QAAS,QAAQ,aAAa,cAAc,mBAAmB,eAAgB,KAAK,QAAQ,aAAa,YAAY,CAAC;AAEhT,SAAK,mBAAmB,0BAA0B,YAAY,UAAU;AAAA,MACtE;AAAA,MACA;AAAA,MACA,eAAe,UAAU,eAAe,UAAU;AAAA,MAClD,YAAY,SAAS,eAAe,SAAS;AAAA,MAC7C;AAAA,IACF,CAAC;AAED,WAAO,aAAa,EAAE,IAAI,MAAM,UAAU,OAAO,aAAa,QAAQ,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EAC3F;AAAA,EAEQ,0BAA0B,UAAsE;AACtG,UAAM,SAAuC,CAAC;AAC9C,UAAM,aAAqC,CAAC;AAG5C,UAAM,gBAAwC,CAAC;AAC/C,eAAW,UAAU,OAAO,OAAO,QAAQ,GAAG;AAC5C,UAAI,OAAO,eAAe,MAAM;AAC9B,cAAM,WAAW,OAAO,wBAAwB,OAAO;AACvD,sBAAc,QAAQ,KAAK,cAAc,QAAQ,KAAK,KAAK;AAAA,MAC7D;AAAA,IACF;AAGA,eAAW,CAAC,IAAI,MAAM,KAAK,OAAO,QAAQ,QAAQ,GAAG;AACnD,UAAI,OAAO,eAAe,MAAM;AAC9B,cAAM,WAAW,OAAO,wBAAwB,OAAO;AACvD,cAAM,SAAS,WAAW,QAAQ,KAAK,KAAK;AAC5C,mBAAW,QAAQ,IAAI;AAEvB,eAAO,EAAE,IAAI;AAAA,UACX,GAAG;AAAA,UACH,sBAAsB;AAAA,UACtB,aAAa,cAAc,QAAQ,IAAI,IAAI,GAAG,QAAQ,IAAI,KAAK,KAAK;AAAA,QACtE;AAAA,MACF,OAAO;AACL,eAAO,EAAE,IAAI;AAAA,MACf;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAMQ,UAAU,OAAsB;AACtC,UAAM,UAAU,KAAK,UAAU,KAAK;AACpC,eAAW,CAAC,cAAc,MAAM,KAAK,KAAK,UAAU;AAClD,UAAI;AACF,eAAO,KAAK,OAAO;AAAA,MACrB,QAAQ;AACN,eAAO,MAAM;AACb,aAAK,SAAS,OAAO,YAAY;AACjC,aAAK,SAAS,OAAO,YAAY;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,kBAAmC;AACzC,WAAO,MAAM,KAAK,KAAK,SAAS,KAAK,CAAC,EAAE;AAAA,MAAI,CAAC,iBAC3C,KAAK,kBAAkB,YAAY;AAAA,IACrC;AAAA,EACF;AAAA,EAEQ,kBAAkB,cAAqC;AAC7D,UAAM,WAAW,KAAK,SAAS,IAAI,YAAY;AAC/C,WAAO;AAAA,MACL;AAAA,MACA,QAAQ,UAAU,UAAU;AAAA,MAC5B,aAAa,UAAU,gBAAe,oBAAI,KAAK,GAAE,YAAY;AAAA,IAC/D;AAAA,EACF;AAAA,EAEQ,eAAe,WAAmB;AACxC,WAAO,gBAAgB,SAAS;AAAA,EAClC;AAAA,EAEQ,eAAe,WAAmB;AACxC,WAAO,gBAAgB,SAAS;AAAA,EAClC;AAAA,EAEQ,iBAA0D;AAChE,QAAI,CAAC,KAAK,IAAI,gBAAgB,CAAC,KAAK,IAAI,2BAA2B;AACjE,aAAO,aAAa,EAAE,OAAO,kCAAkC,GAAG,GAAG;AAAA,IACvE;AAEA,WAAO,EAAE,KAAK,KAAK,IAAI,cAAc,KAAK,KAAK,IAAI,0BAA0B;AAAA,EAC/E;AAAA,EAEA,MAAc,gBACZ,OACA,SACA,SAC0B;AAC1B,UAAM,SAAS,KAAK,eAAe;AACnC,QAAI,kBAAkB,UAAU;AAC9B,aAAO;AAAA,IACT;AAEA,UAAM,MAAM,IAAI,IAAI,YAAY,KAAK,IAAI,OAAO,GAAG;AACnD,QAAI,SAAS,QAAQ;AACnB,UAAI,aAAa,IAAI,eAAe,IAAI;AAAA,IAC1C;AACA,UAAM,WAAW,MAAM,MAAM,IAAI,SAAS,GAAG;AAAA,MAC3C,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,QAChB,QAAQ,OAAO;AAAA,QACf,eAAe,UAAU,OAAO,GAAG;AAAA,QACnC,QAAQ,SAAS,SACb,gDACA;AAAA,MACN;AAAA,MACA,MAAM,KAAK,UAAU,OAAO;AAAA,IAC9B,CAAC;AAED,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,YAAY,MAAM,SAAS,KAAK;AACtC,aAAO;AAAA,QACL,EAAE,OAAO,8BAA8B,KAAK,KAAK,SAAS,UAAU;AAAA,QACpE;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,2BACZ,YAC6C;AAC7C,UAAM,SAAS,KAAK,eAAe;AACnC,QAAI,kBAAkB,UAAU;AAC9B,aAAO;AAAA,IACT;AAEA,UAAM,UAAU;AAAA,MACd,QAAQ,OAAO;AAAA,MACf,eAAe,UAAU,OAAO,GAAG;AAAA,IACrC;AAEA,UAAM,gBAAgB,IAAI,IAAI,gCAAgC,OAAO,GAAG;AACxE,kBAAc,aAAa;AAAA,MACzB;AAAA,MACA;AAAA,IACF;AACA,kBAAc,aAAa,IAAI,eAAe,MAAM,UAAU,EAAE;AAChE,kBAAc,aAAa,IAAI,aAAa,SAAS;AAErD,UAAM,YAAY,IAAI,IAAI,8CAA8C,OAAO,GAAG;AAClF,cAAU,aAAa,IAAI,UAAU,mCAAmC;AACxE,cAAU,aAAa,IAAI,eAAe,MAAM,UAAU,EAAE;AAE5D,UAAM,YAAY,IAAI,IAAI,sCAAsC,OAAO,GAAG;AAC1E,cAAU,aAAa,IAAI,UAAU,0BAA0B;AAC/D,cAAU,aAAa,IAAI,eAAe,MAAM,UAAU,EAAE;AAE5D,UAAM,CAAC,cAAc,WAAW,SAAS,IAAI,MAAM,QAAQ,IAAI;AAAA,MAC7D,MAAM,cAAc,SAAS,GAAG,EAAE,QAAQ,CAAC;AAAA,MAC3C,MAAM,UAAU,SAAS,GAAG,EAAE,QAAQ,CAAC;AAAA,MACvC,MAAM,UAAU,SAAS,GAAG,EAAE,QAAQ,CAAC;AAAA,IACzC,CAAC;AAED,QAAI,CAAC,aAAa,IAAI;AACpB,YAAM,UAAU,MAAM,aAAa,KAAK;AACxC,aAAO;AAAA,QACL,EAAE,OAAO,4CAA4C,QAAQ;AAAA,QAC7D;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,UAAU,IAAI;AACjB,YAAM,UAAU,MAAM,UAAU,KAAK;AACrC,aAAO;AAAA,QACL,EAAE,OAAO,0DAA0D,QAAQ;AAAA,QAC3E;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,UAAU,IAAI;AACjB,YAAM,UAAU,MAAM,UAAU,KAAK;AACrC,aAAO;AAAA,QACL,EAAE,OAAO,kDAAkD,QAAQ;AAAA,QACnE;AAAA,MACF;AAAA,IACF;AAEA,UAAM,gBAAiB,MAAM,aAAa,KAAK;AAS/C,UAAM,aAAc,MAAM,UAAU,KAAK;AAKzC,UAAM,YAAa,MAAM,UAAU,KAAK;AAKxC,UAAM,aAAa,oBAAI,IAAsB;AAC7C,eAAW,QAAQ,CAAC,QAAQ;AAC1B,UAAI,IAAI,cAAc,MAAO;AAC7B,YAAM,OAAO,WAAW,IAAI,IAAI,YAAY,KAAK,CAAC;AAClD,WAAK,KAAK,IAAI,UAAU;AACxB,iBAAW,IAAI,IAAI,cAAc,IAAI;AAAA,IACvC,CAAC;AAED,UAAM,aAAa,oBAAI,IAAoB;AAC3C,cAAU,QAAQ,CAAC,QAAQ;AACzB,YAAM,UAAU,WAAW,IAAI,IAAI,YAAY,KAAK;AACpD,YAAM,YAAY,OAAO,IAAI,gBAAgB,WAAW,IAAI,cAAc;AAC1E,iBAAW,IAAI,IAAI,cAAc,UAAU,SAAS;AAAA,IACtD,CAAC;AAED,UAAM,aAAa,wBAAC,UAClB,OAAO,UAAU,YAAY,OAAO,SAAS,KAAK,IAAI,QAAQ,GAD7C;AAGnB,WAAO,cAAc,IAAI,CAAC,SAAS;AAAA,MACjC,IAAI,IAAI;AAAA,MACR,YAAY,WAAW,IAAI,UAAU;AAAA,MACrC,cACE,OAAO,IAAI,WAAW,YAAY,OAAO,SAAS,IAAI,MAAM,IACxD,IAAI,SACJ,WAAW,IAAI,UAAU;AAAA,MAC/B,QACE,OAAO,IAAI,eAAe,YAAY,OAAO,SAAS,IAAI,UAAU,IAChE,IAAI,aACJ,WAAW,IAAI,cAAc;AAAA,MACnC,eAAe,WAAW,IAAI,IAAI,EAAE,KAAK,CAAC;AAAA,MAC1C,QAAQ,WAAW,IAAI,IAAI,EAAE,KAAK;AAAA,IACpC,EAAE;AAAA,EACJ;AACF;AAEA,SAAS,aAAa,MAAe,SAAS,KAAK,SAAuB,SAAmB;AAC3F,QAAM,cAAc,UAAU,eAAe,OAAO,IAAI,CAAC;AACzD,SAAO,IAAI,SAAS,KAAK,UAAU,IAAI,GAAG;AAAA,IACxC;AAAA,IACA,SAAS;AAAA,MACP,gBAAgB;AAAA,MAChB,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAAA,EACF,CAAC;AACH;AAVS;AAYT,eAAe,aAAa,SAA+C;AACzE,MAAI,CAAC,QAAQ,QAAQ,IAAI,cAAc,GAAG,SAAS,kBAAkB,GAAG;AACtE,WAAO,aAAa,EAAE,OAAO,qBAAqB,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EACvE;AAEA,MAAI;AACF,WAAO,MAAM,QAAQ,KAAK;AAAA,EAC5B,QAAQ;AACN,WAAO,aAAa,EAAE,OAAO,eAAe,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EACjE;AACF;AAVe;AAYf,SAAS,SAAS,OAAkD;AAClE,SAAO,OAAO,UAAU,YAAY,UAAU;AAChD;AAFS;AAIT,SAAS,iBACP,OACA,OACA,WAAW,OACX,SAC+B;AAC/B,MAAI,SAAS,MAAM;AACjB,QAAI,UAAU;AACZ,aAAO,aAAa,EAAE,OAAO,WAAW,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACtE;AACA,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,UAAU,YAAY,MAAM,KAAK,EAAE,WAAW,GAAG;AAC1D,WAAO,aAAa,EAAE,OAAO,WAAW,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EACtE;AAEA,SAAO;AACT;AAlBS;AAoBT,SAAS,yBAAyB,OAAgB,OAAe,SAAsC;AACrG,QAAM,SAAS,iBAAiB,OAAO,OAAO,MAAM,OAAO;AAC3D,MAAI,kBAAkB,UAAU;AAC9B,WAAO;AAAA,EACT;AACA,SAAO;AACT;AANS;AAQT,SAAS,iBACP,OACA,OACA,WAAW,GACX,SACmB;AACnB,MAAI,SAAS,MAAM;AACjB,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,UAAU,YAAY,OAAO,SAAS,KAAK,GAAG;AACvD,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,UAAU,UAAU;AAC7B,UAAM,SAAS,OAAO,KAAK;AAC3B,QAAI,OAAO,SAAS,MAAM,GAAG;AAC3B,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO,aAAa,EAAE,OAAO,WAAW,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG,OAAO;AACtE;AAtBS;AAwBT,SAAS,kBACP,OACA,OACA,WAAW,OACX,SACoB;AACpB,MAAI,SAAS,MAAM;AACjB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,WAAW;AAC9B,WAAO;AAAA,EACT;AACA,SAAO,aAAa,EAAE,OAAO,WAAW,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG,OAAO;AACtE;AAbS;AAeT,SAAS,sBACP,OACA,OACA,SACiC;AACjC,MAAI,SAAS,MAAM;AACjB,WAAO;AAAA,EACT;AACA,MAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,WAAO,aAAa,EAAE,OAAO,WAAW,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,EACtE;AACA,aAAW,SAAS,OAAO;AACzB,QAAI,OAAO,UAAU,UAAU;AAC7B,aAAO,aAAa,EAAE,OAAO,WAAW,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG,OAAO;AAAA,IACtE;AAAA,EACF;AACA,SAAO;AACT;AAjBS;AAmBT,SAAS,iBAAiB,MAA8C;AACtE,MAAI,CAAC,SAAS,IAAI,GAAG;AACnB,WAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,GAAG;AAAA,EACxD;AAEA,MAAI,KAAK,cAAc,QAAQ,CAAC,MAAM,QAAQ,KAAK,UAAU,GAAG;AAC9D,WAAO,aAAa,EAAE,OAAO,sBAAsB,GAAG,GAAG;AAAA,EAC3D;AAEA,QAAM,kBAAkB,kBAAkB,KAAK,iBAAiB,iBAAiB;AACjF,MAAI,2BAA2B,UAAU;AACvC,WAAO;AAAA,EACT;AAEA,QAAM,cAAc,sBAAsB,KAAK,aAAa,aAAa;AACzE,MAAI,uBAAuB,UAAU;AACnC,WAAO;AAAA,EACT;AAEA,QAAM,aAAsC,CAAC;AAE7C,aAAW,SAAS,KAAK,cAAc,CAAC,GAAG;AACzC,QAAI,CAAC,SAAS,KAAK,GAAG;AACpB,aAAO,aAAa,EAAE,OAAO,2BAA2B,GAAG,GAAG;AAAA,IAChE;AACA,UAAM,KAAK,yBAAyB,MAAM,IAAI,eAAe;AAC7D,QAAI,cAAc,UAAU;AAC1B,aAAO;AAAA,IACT;AACA,UAAM,aAAa,iBAAiB,MAAM,YAAY,uBAAuB;AAC7E,QAAI,sBAAsB,UAAU;AAClC,aAAO;AAAA,IACT;AACA,UAAM,iBAAiB,iBAAiB,MAAM,gBAAgB,2BAA2B;AACzF,QAAI,0BAA0B,UAAU;AACtC,aAAO;AAAA,IACT;AACA,UAAM,kBAAkB;AAAA,MACtB,MAAM;AAAA,MACN;AAAA,IACF;AACA,QAAI,2BAA2B,UAAU;AACvC,aAAO;AAAA,IACT;AACA,UAAM,eAAe,iBAAiB,MAAM,cAAc,yBAAyB;AACnF,QAAI,wBAAwB,UAAU;AACpC,aAAO;AAAA,IACT;AACA,UAAM,SAAS,iBAAiB,MAAM,QAAQ,mBAAmB;AACjE,QAAI,kBAAkB,UAAU;AAC9B,aAAO;AAAA,IACT;AACA,UAAM,SAAS,iBAAiB,MAAM,QAAQ,mBAAmB;AACjE,QAAI,kBAAkB,UAAU;AAC9B,aAAO;AAAA,IACT;AACA,UAAM,gBAAgB;AAAA,MACpB,MAAM;AAAA,MACN;AAAA,IACF;AACA,QAAI,yBAAyB,UAAU;AACrC,aAAO;AAAA,IACT;AACA,UAAM,UAAU,iBAAiB,MAAM,SAAS,oBAAoB;AACpE,QAAI,mBAAmB,UAAU;AAC/B,aAAO;AAAA,IACT;AACA,UAAM,WAAW,kBAAkB,MAAM,UAAU,qBAAqB;AACxE,QAAI,oBAAoB,UAAU;AAChC,aAAO;AAAA,IACT;AAEA,eAAW,KAAK;AAAA,MACd;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AA3FS;AA6FT,SAAS,mBAAmB,MAAgD;AAC1E,MAAI,CAAC,SAAS,IAAI,GAAG;AACnB,WAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,GAAG;AAAA,EACxD;AAEA,MAAI;AACJ,MAAI,KAAK,qBAAqB,MAAM;AAClC,QAAI,CAAC,SAAS,KAAK,iBAAiB,GAAG;AACrC,aAAO,aAAa,EAAE,OAAO,6BAA6B,GAAG,GAAG;AAAA,IAClE;AACA,wBAAoB,CAAC;AACrB,eAAW,CAAC,aAAa,UAAU,KAAK,OAAO,QAAQ,KAAK,iBAAiB,GAAG;AAC9E,YAAM,SAAS,sBAAsB,YAAY,mBAAmB;AACpE,UAAI,kBAAkB,UAAU;AAC9B,eAAO;AAAA,MACT;AACA,wBAAkB,WAAW,IAAI,UAAU,CAAC;AAAA,IAC9C;AAAA,EACF;AAEA,SAAO,EAAE,kBAAkB;AAC7B;AArBS;AAuBT,SAAS,kBAAkB,MAA+C;AACxE,MAAI,CAAC,SAAS,IAAI,GAAG;AACnB,WAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,GAAG;AAAA,EACxD;AAEA,QAAM,cAAc,iBAAiB,KAAK,aAAa,aAAa;AACpE,MAAI,uBAAuB,UAAU;AACnC,WAAO;AAAA,EACT;AAEA,SAAO,EAAE,YAAY;AACvB;AAXS;AAaT,SAAS,iBAAiB,MAA8C;AACtE,MAAI,CAAC,SAAS,IAAI,GAAG;AACnB,WAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,GAAG;AAAA,EACxD;AAEA,QAAM,cAAc,yBAAyB,KAAK,aAAa,aAAa;AAC5E,MAAI,uBAAuB,UAAU;AACnC,WAAO;AAAA,EACT;AACA,QAAM,kBAAkB,iBAAiB,KAAK,iBAAiB,iBAAiB;AAChF,MAAI,2BAA2B,UAAU;AACvC,WAAO;AAAA,EACT;AACA,QAAM,aAAa,iBAAiB,KAAK,YAAY,YAAY;AACjE,MAAI,sBAAsB,UAAU;AAClC,WAAO;AAAA,EACT;AACA,QAAM,aAAa,iBAAiB,KAAK,YAAY,YAAY;AACjE,MAAI,sBAAsB,UAAU;AAClC,WAAO;AAAA,EACT;AACA,QAAM,WAAW,iBAAiB,KAAK,UAAU,UAAU;AAC3D,MAAI,oBAAoB,UAAU;AAChC,WAAO;AAAA,EACT;AACA,QAAM,cAAc,KAAK;AACzB,QAAM,WAAW,KAAK;AAEtB,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AArCS;AAuCT,SAAS,oBAAoB,MAAiD;AAC5E,MAAI,CAAC,SAAS,IAAI,GAAG;AACnB,WAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,GAAG;AAAA,EACxD;AAEA,QAAM,cAAc,yBAAyB,KAAK,aAAa,aAAa;AAC5E,MAAI,uBAAuB,UAAU;AACnC,WAAO;AAAA,EACT;AACA,QAAM,kBAAkB,iBAAiB,KAAK,iBAAiB,iBAAiB;AAChF,MAAI,2BAA2B,UAAU;AACvC,WAAO;AAAA,EACT;AACA,QAAM,eAAe,iBAAiB,KAAK,cAAc,cAAc;AACvE,MAAI,wBAAwB,UAAU;AACpC,WAAO;AAAA,EACT;AACA,QAAM,WAAW,KAAK;AAEtB,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAzBS;AA2BT,SAAS,0BAA0B,MAAuB,SAAwC;AAChG,SAAO;AAAA,IACL,IAAI,OAAO,WAAW;AAAA,IACtB;AAAA,IACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IAClC;AAAA,EACF;AACF;AAPS;AAST,SAAS,iBAAiB,MAA8C;AACtE,MAAI,CAAC,SAAS,IAAI,GAAG;AACnB,WAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,GAAG;AAAA,EACxD;AAEA,QAAM,WAAW,yBAAyB,KAAK,UAAU,UAAU;AACnE,MAAI,oBAAoB,UAAU;AAChC,WAAO;AAAA,EACT;AAEA,QAAM,WAAW,iBAAiB,KAAK,UAAU,UAAU;AAC3D,MAAI,oBAAoB,UAAU;AAChC,WAAO;AAAA,EACT;AAEA,QAAM,aAAa,iBAAiB,KAAK,YAAY,YAAY;AACjE,MAAI,sBAAsB,UAAU;AAClC,WAAO;AAAA,EACT;AAEA,QAAM,QAAQ,iBAAiB,KAAK,OAAO,OAAO;AAClD,MAAI,iBAAiB,UAAU;AAC7B,WAAO;AAAA,EACT;AAEA,QAAM,QAAQ,iBAAiB,KAAK,OAAO,OAAO;AAClD,MAAI,iBAAiB,UAAU;AAC7B,WAAO;AAAA,EACT;AAEA,QAAM,YAAY,iBAAiB,KAAK,WAAW,WAAW;AAC9D,MAAI,qBAAqB,UAAU;AACjC,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AA3CS;AA6CT,SAAS,sBAAsB,MAAmD;AAChF,MAAI,CAAC,SAAS,IAAI,GAAG;AACnB,WAAO,aAAa,EAAE,OAAO,mBAAmB,GAAG,GAAG;AAAA,EACxD;AAEA,QAAM,YAAY,yBAAyB,KAAK,WAAW,WAAW;AACtE,MAAI,qBAAqB,UAAU;AACjC,WAAO;AAAA,EACT;AAEA,QAAM,OAAO,yBAAyB,KAAK,MAAM,MAAM;AACvD,MAAI,gBAAgB,UAAU;AAC5B,WAAO;AAAA,EACT;AAEA,QAAM,cAAc,iBAAiB,KAAK,aAAa,aAAa;AACpE,MAAI,uBAAuB,UAAU;AACnC,WAAO;AAAA,EACT;AAEA,QAAM,SAAS,iBAAiB,KAAK,QAAQ,QAAQ;AACrD,MAAI,kBAAkB,UAAU;AAC9B,WAAO;AAAA,EACT;AAEA,QAAM,UAAU,iBAAiB,KAAK,SAAS,SAAS;AACxD,MAAI,mBAAmB,UAAU;AAC/B,WAAO;AAAA,EACT;AAEA,QAAM,YAAY,iBAAiB,KAAK,WAAW,WAAW;AAC9D,MAAI,qBAAqB,UAAU;AACjC,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AA3CS;AA6CT,SAAS,WAAmB;AAC1B,QAAM,SAAS,IAAI,YAAY,CAAC;AAChC,SAAO,gBAAgB,MAAM;AAC7B,SAAQ,OAAO,CAAC,IAAI,MAAO;AAC7B;AAJS;AAMT,SAAS,0BAA0B,QAAoD;AACrF,SAAO;AAAA,IACL,IAAI,OAAO;AAAA,IACX,aAAa,OAAO;AAAA,IACpB,WAAW,OAAO;AAAA,IAClB,aAAa,OAAO,cAAc;AAAA,IAClC,MAAM,OAAO;AAAA,IACb,UAAU,OAAO;AAAA,IACjB,OAAO,OAAO;AAAA,IACd,OAAO,OAAO,SAAS;AAAA,IACvB,OAAO,OAAO,SAAS;AAAA,IACvB,QAAQ,OAAO;AAAA,IACf,YAAY,OAAO,aAAa;AAAA,IAChC,YAAY,OAAO;AAAA,EACrB;AACF;AAfS;AAiBT,SAAS,sBAAsB,QAAgD;AAC7E,SAAO;AAAA,IACL,IAAI,OAAO;AAAA,IACX,aAAa,OAAO;AAAA,IACpB,iBAAiB,OAAO;AAAA,IACxB,OAAO,OAAO;AAAA,IACd,SAAS,OAAO,UAAU;AAAA,IAC1B,UAAU,OAAO,WAAW;AAAA,IAC5B,cAAc,OAAO;AAAA,IACrB,UAAU,OAAO;AAAA,IACjB,WAAW,OAAO;AAAA,IAClB,aAAa,OAAO;AAAA,IACpB,iBAAiB,OAAO;AAAA,IACxB,cAAc,OAAO;AAAA,IACrB,SAAS,OAAO;AAAA,IAChB,YAAY,OAAO;AAAA,EACrB;AACF;AAjBS;AAmBT,IAAO,iBAAQ;AAAA,EACb,MAAM,MAAM,SAAkB,KAA6B;AACzD,UAAM,cAAc,eAAe,OAAO;AAG1C,QAAI,QAAQ,WAAW,WAAW;AAChC,aAAO,IAAI,SAAS,MAAM;AAAA,QACxB,QAAQ;AAAA,QACR,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAEA,UAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,UAAM,QAAQ,IAAI,SAAS,MAAM,qDAAqD;AACtF,UAAM,cAAc,IAAI,SAAS;AAAA,MAC/B;AAAA,IACF;AACA,QAAI,CAAC,SAAS,CAAC,aAAa;AAC1B,aAAO,IAAI;AAAA,QACT,KAAK,UAAU,EAAE,OAAO,YAAY,CAAC;AAAA,QACrC;AAAA,UACE,QAAQ;AAAA,UACR,SAAS;AAAA,YACP,gBAAgB;AAAA,YAChB,GAAG;AAAA,UACL;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,aAAa,oBAAoB,SAAS,aAAc,CAAC,CAAC;AAChE,UAAM,KAAK,IAAI,YAAY,WAAW,UAAU;AAChD,UAAM,OAAO,IAAI,YAAY,IAAI,EAAE;AAEnC,WAAO,KAAK,MAAM,OAAO;AAAA,EAC3B;AACF;;;AC7lHA,IAAM,YAAwB,8BAAO,SAAS,KAAK,MAAM,kBAAkB;AAC1E,MAAI;AACH,WAAO,MAAM,cAAc,KAAK,SAAS,GAAG;AAAA,EAC7C,UAAE;AACD,QAAI;AACH,UAAI,QAAQ,SAAS,QAAQ,CAAC,QAAQ,UAAU;AAC/C,cAAM,SAAS,QAAQ,KAAK,UAAU;AACtC,eAAO,EAAE,MAAM,OAAO,KAAK,GAAG,MAAM;AAAA,QAAC;AAAA,MACtC;AAAA,IACD,SAAS,GAAG;AACX,cAAQ,MAAM,4CAA4C,CAAC;AAAA,IAC5D;AAAA,EACD;AACD,GAb8B;AAe9B,IAAO,6CAAQ;;;ACRf,SAAS,YAAY,GAAmB;AACvC,SAAO;AAAA,IACN,MAAM,GAAG;AAAA,IACT,SAAS,GAAG,WAAW,OAAO,CAAC;AAAA,IAC/B,OAAO,GAAG;AAAA,IACV,OAAO,GAAG,UAAU,SAAY,SAAY,YAAY,EAAE,KAAK;AAAA,EAChE;AACD;AAPS;AAUT,IAAM,YAAwB,8BAAO,SAAS,KAAK,MAAM,kBAAkB;AAC1E,MAAI;AACH,WAAO,MAAM,cAAc,KAAK,SAAS,GAAG;AAAA,EAC7C,SAAS,GAAQ;AAChB,UAAM,QAAQ,YAAY,CAAC;AAC3B,WAAO,SAAS,KAAK,OAAO;AAAA,MAC3B,QAAQ;AAAA,MACR,SAAS,EAAE,+BAA+B,OAAO;AAAA,IAClD,CAAC;AAAA,EACF;AACD,GAV8B;AAY9B,IAAO,2CAAQ;;;ACzBJ,IAAM,mCAAmC;AAAA,EAE9B;AAAA,EAAyB;AAC3C;AACA,IAAO,sCAAQ;;;ACcnB,IAAM,wBAAsC,CAAC;AAKtC,SAAS,uBAAuB,MAAqC;AAC3E,wBAAsB,KAAK,GAAG,KAAK,KAAK,CAAC;AAC1C;AAFgB;AAShB,SAAS,uBACR,SACA,KACA,KACA,UACA,iBACsB;AACtB,QAAM,CAAC,MAAM,GAAG,IAAI,IAAI;AACxB,QAAM,gBAAmC;AAAA,IACxC;AAAA,IACA,KAAK,YAAY,QAAQ;AACxB,aAAO,uBAAuB,YAAY,QAAQ,KAAK,UAAU,IAAI;AAAA,IACtE;AAAA,EACD;AACA,SAAO,KAAK,SAAS,KAAK,KAAK,aAAa;AAC7C;AAfS;AAiBF,SAAS,kBACf,SACA,KACA,KACA,UACA,iBACsB;AACtB,SAAO,uBAAuB,SAAS,KAAK,KAAK,UAAU;AAAA,IAC1D,GAAG;AAAA,IACH;AAAA,EACD,CAAC;AACF;AAXgB;;;AC3ChB,IAAM,iCAAN,MAAM,gCAA8D;AAAA,EAGnE,YACU,eACA,MACT,SACC;AAHQ;AACA;AAGT,SAAK,WAAW;AAAA,EACjB;AAAA,EArBD,OAYoE;AAAA;AAAA;AAAA,EAC1D;AAAA,EAUT,UAAU;AACT,QAAI,EAAE,gBAAgB,kCAAiC;AACtD,YAAM,IAAI,UAAU,oBAAoB;AAAA,IACzC;AAEA,SAAK,SAAS;AAAA,EACf;AACD;AAEA,SAAS,oBAAoB,QAA0C;AAEtE,MACC,qCAAqC,UACrC,iCAAiC,WAAW,GAC3C;AACD,WAAO;AAAA,EACR;AAEA,aAAW,cAAc,kCAAkC;AAC1D,wBAAoB,UAAU;AAAA,EAC/B;AAEA,QAAM,kBAA+C,gCACpD,SACA,KACA,KACC;AACD,QAAI,OAAO,UAAU,QAAW;AAC/B,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC9D;AACA,WAAO,OAAO,MAAM,SAAS,KAAK,GAAG;AAAA,EACtC,GATqD;AAWrD,SAAO;AAAA,IACN,GAAG;AAAA,IACH,MAAM,SAAS,KAAK,KAAK;AACxB,YAAM,aAAyB,gCAAU,MAAM,MAAM;AACpD,YAAI,SAAS,eAAe,OAAO,cAAc,QAAW;AAC3D,gBAAM,aAAa,IAAI;AAAA,YACtB,KAAK,IAAI;AAAA,YACT,KAAK,QAAQ;AAAA,YACb,MAAM;AAAA,YAAC;AAAA,UACR;AACA,iBAAO,OAAO,UAAU,YAAY,KAAK,GAAG;AAAA,QAC7C;AAAA,MACD,GAT+B;AAU/B,aAAO,kBAAkB,SAAS,KAAK,KAAK,YAAY,eAAe;AAAA,IACxE;AAAA,EACD;AACD;AAxCS;AA0CT,SAAS,qBACR,OAC8B;AAE9B,MACC,qCAAqC,UACrC,iCAAiC,WAAW,GAC3C;AACD,WAAO;AAAA,EACR;AAEA,aAAW,cAAc,kCAAkC;AAC1D,wBAAoB,UAAU;AAAA,EAC/B;AAGA,SAAO,cAAc,MAAM;AAAA,IAC1B,mBAAyE,wBACxE,SACA,KACA,QACI;AACJ,WAAK,MAAM;AACX,WAAK,MAAM;AACX,UAAI,MAAM,UAAU,QAAW;AAC9B,cAAM,IAAI,MAAM,sDAAsD;AAAA,MACvE;AACA,aAAO,MAAM,MAAM,OAAO;AAAA,IAC3B,GAXyE;AAAA,IAazE,cAA0B,wBAAC,MAAM,SAAS;AACzC,UAAI,SAAS,eAAe,MAAM,cAAc,QAAW;AAC1D,cAAM,aAAa,IAAI;AAAA,UACtB,KAAK,IAAI;AAAA,UACT,KAAK,QAAQ;AAAA,UACb,MAAM;AAAA,UAAC;AAAA,QACR;AACA,eAAO,MAAM,UAAU,UAAU;AAAA,MAClC;AAAA,IACD,GAT0B;AAAA,IAW1B,MAAM,SAAwD;AAC7D,aAAO;AAAA,QACN;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,MACN;AAAA,IACD;AAAA,EACD;AACD;AAnDS;AAqDT,IAAI;AACJ,IAAI,OAAO,wCAAU,UAAU;AAC9B,kBAAgB,oBAAoB,mCAAK;AAC1C,WAAW,OAAO,wCAAU,YAAY;AACvC,kBAAgB,qBAAqB,mCAAK;AAC3C;AACA,IAAO,kCAAQ;",
  "names": ["sequence"]
}
